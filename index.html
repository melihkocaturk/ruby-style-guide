<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="author" content="Melih Kocatürk">
    <meta name="description" content="Ruby Stil Rehberi">
    <link rel="stylesheet" href="assets/css/vendor.css" />
    <link rel="stylesheet" href="assets/css/style.css" />

    <title>Ruby Stil Rehberi</title>
  </head>
  <body data-spy="scroll" data-target="#toc">

    <section class="py-0">
      <div class="container-fluid">
        <div class="row justify-content-between">

          <!-- navigation -->
          <aside class="col-lg-3 col-xxl-2 p-3 doc-sidebar">
            <div class="sticky">
              <nav class="navbar navbar-vertical navbar-expand-lg navbar-light">
                <div>
                  <a href="index.html" class="navbar-brand"><img src="assets/images/logo.png" alt="Logo"><span class="badge badge-red ml-2">1.0.0</span></a>
                  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                  </button>
                </div>

                <div class="collapse navbar-collapse" id="navbarSupportedContent">
                  <ul id="page-nav" class="nav flex-column nav-vertical-2">
                    <li class="nav-item active">
                      <a class="nav-link" data-toggle="collapse" href="#menu-1" role="button" aria-expanded="true" aria-controls="menu-1">Stil Rehberi</a>
                      <div class="collapse show" id="menu-1" data-parent="#page-nav">
                        <ul class="nav flex-column">
                          <li class="nav-item">
                            <a class="nav-link active" href="index.html">Ruby</a>
                          </li>
                          <li class="nav-item">
                            <a class="nav-link" href="rails.html">Ruby on Rails</a>
                          </li>
                        </ul>
                      </div>
                      <li class="nav-item">
                        <a class="nav-link" data-toggle="collapse" href="#menu-2" role="button" aria-expanded="false" aria-controls="menu-2">Belgeler</a>
                        <div class="collapse" id="menu-2" data-parent="#page-nav">
                          <div>
                            <ul class="nav flex-column">
                              <li class="nav-item">
                                <a class="nav-link" href="http://www.ruby-doc.org/docs/ProgrammingRuby/" target="blank" ref="nofollow">Ruby Programlama</a>
                              </li>
                              <li class="nav-item">
                                <a class="nav-link" href="http://www.belgeler.org/uygulamalar/ruby/ruby-ug.html" target="blank" ref="nofollow">Ruby Kullanıcı Kılavuzu</a>
                              </li>
                              <li class="nav-item">
                                <a class="nav-link" href="http://en.wikibooks.org/wiki/Ruby_programming_language" target="blank" ref="nofollow">Ruby Wiki</a>
                              </li>
                            </ul>
                          </div>
                        </div>
                      </li>
                      <li class="nav-item">
                        <a class="nav-link" data-toggle="collapse" href="#menu-3" role="button" aria-expanded="false" aria-controls="menu-3">Kütüphaneler</a>
                        <div class="collapse" id="menu-3" data-parent="#page-nav">
                          <div>
                            <ul class="nav flex-column">
                              <li class="nav-item">
                                <a class="nav-link" href="http://rubyforge.org/" target="blank" ref="nofollow">RubyForge</a>
                              </li>
                              <li class="nav-item">
                                <a class="nav-link" href="https://guides.rubygems.org/" target="blank" ref="nofollow">RubyGems</a>
                              </li>
                            </ul>
                          </div>
                        </div>
                      </li>
                      <li class="nav-item">
                        <a class="nav-link" data-toggle="collapse" href="#menu-4" role="button" aria-expanded="false" aria-controls="menu-4">Topluluk</a>
                        <div class="collapse" id="menu-4" data-parent="#page-nav">
                          <div>
                            <ul class="nav flex-column">
                              <li class="nav-item">
                                <a class="nav-link" href="http://rubyusergroups.org/" target="blank" ref="nofollow">Ruby Kullanıcı Grupları</a>
                              </li>
                              <li class="nav-item">
                                <a class="nav-link" href="https://rubyweekly.com/" target="blank" ref="nofollow">Ruby Weekly</a>
                              </li>
                              <li class="nav-item">
                                <a class="nav-link" href="http://www.rubyflow.com/" target="blank" ref="nofollow">RubyFlow</a>
                              </li>
                            </ul>
                          </div>
                        </div>
                      </li>
                    </li>
                  </ul>
                </div>
              </nav>
            </div>
          </aside>
          <!-- / navigation -->

          <!-- content -->
          <article class="col-lg-9 col-xxl-10 doc-content">

            <div class="row justify-content-between doc-content-body">
              <article class="col-md-9 col-xxl-8">

                <h1 class="h2 font-weight-light"><b>Ruby</b> Stil Rehberi</h1>

                <section>
                  <h2 class="section-title-2">Giriş</h2>
                  <p>Ruby geliştiricisi olarak bir şey beni her zaman rahatsız etti - Python geliştiricileri harika bir programlama stili referansına (PEP-8) sahipler ve Ruby kodlama stilini ve en iyi uygulamaları belgeleyen resmi bir rehberimiz olmadı. Ve stilin önemli olduğuna inanıyorum, ayrıca Ruby gibi büyük bir hacker topluluğu bu belgeyi üretebilecek kapasitede olmalı.</p>
                  <p>Bu rehber, şirketimizin Ruby kodlama yönergeleri olarak hayatına başladı. Bir noktada, yaptığım işin genel olarak Ruby topluluğunun üyeleri için ilginç olabileceğine ve dünyanın başka bir şirket içi rehbere ihtiyaç duymadığına karar verdim. Ancak dünya, Ruby programcılığına yönelik, topluluğun yürüttüğü ve topluluğun onayladığı uygulamalardan ve stil reçetelerinden kesinlikle yararlanabilir.</p>
                  <p>Rehberin başlangıcından beri, dünyanın her tarafındaki olağanüstü Ruby topluluğu üyelerinden çok fazla geri bildirim aldım. Tüm öneri ve destek için teşekkür ederiz! Birlikte, her Ruby geliştiricisi için bir kaynak sağlayabiliriz.</p>
                  <p>Bu arada, Rails ile ilgileniyorsanız tamamlayıcı <a href="rails.html">Ruby on Rails Stil Rehberi</a>'ne göz atmak isteyebilirsiniz.</p>
                </section>

                <!-- source code layout  -->
                <section id="section-1">
                  <h2 class="section-title-2">Kaynak Kod Düzeni <a data-scroll href="#section-1" class="anchor" data-toggle="tooltip" data-placement="top" title="Linki kopyala"><i class="icon-hash"></i></a></h2>
                  <ul>
                    <li><p>Kaynak dosya kodlaması olarak UTF-8 kullanın.</p></li>
                    <li>
                      <p>Girinti seviyesi başına iki boşluk kullanın (yumuşak sekme). Sert sekme kullanmayın.</p>
                      <pre><code class="language-ruby"># bad - four spaces
def some_method
    do_something
end

# good
def some_method
  do_something
end</code></pre>
                    </li>
                    <li>
                      <p>Unix tarzı satır sonları kullanın. (*BSD, Solaris, Linux, macOS kullanıcıları varsayılan olarak karşılanır, Windows kullanıcılarının daha dikkatli olmaları gerekir.)</p>
                      <p>Git kullanıyorsanız, projenizi Windows satır sonlarından korumak için aşağıdaki yapılandırma ayarını eklemek isteyebilirsiniz.</p>
                      <pre><code  class="language-bash">$ git config --global core.autocrlf true</code></pre>
                    </li>
                    <li>
                      <p>İfadeleri ayırmak için <code>;</code> kullanmayın. Sonuç olarak her satırda bir ifade kullanın.</p>
                      <pre><code class="language-ruby"># bad
puts 'foobar'; # superfluous semicolon

puts 'foo'; puts 'bar' # two expressions on the same line

# good
puts 'foobar'

puts 'foo'
puts 'bar'

puts 'foo', 'bar' # this applies to puts in particular</code></pre>
                    </li>
                    <li>
                      <p>Gövdesiz sınıf tanımları için tek satırlı bir format seçin.</p>
                      <pre><code class="language-ruby"># bad
class FooError < StandardError
end

# okish
class FooError < StandardError; end

# good
FooError = Class.new(StandardError)</code></pre>
                    </li>
                    <li>
                      <p>Tek satırlı yöntemlerden kaçının. Vahşi doğada biraz popüler olsalarda, sözdizimleri yüzünden kullanılmaları tercih edilmez. Her halükarda - tek satırlı bir yöntemde birden fazla ifade bulunmamalıdır.</p>
                      <pre><code class="language-ruby"># bad
def too_much; something; something_else; end

# okish - notice that the first ; is required
def no_braces_method; body end

# okish - notice that the second ; is optional
def no_braces_method; body; end

# okish - valid syntax, but no ; makes it kind of hard to read
def some_method() body end

# good
def some_method
  body
end</code></pre>
                      <p>Kuralın bir istisnası boş gövdeli yöntemlerdir.</p>
<pre><code class="language-ruby"># good
def no_op; end</code></pre>
                    </li>
                    <li>
                      <p>Operatörlerin etrafında, virgül, iki nokta üst üste ve noktalı virgülden sonra boşluk kullanın. Boşluk karakteri (çoğunlukla) Ruby yorumlayıcısı için anlamsızdır, ancak uygun kullanımı kolayca okunabilir kod yazmanın anahtarıdır.</p>
                      <pre><code class="language-ruby">sum = 1 + 2
a, b = 1, 2
class FooError < StandardError; end</code></pre>
                      <p>Bir kaç istisna var. Bir tanesi üs operatörü:</p>
                      <pre><code class="language-ruby"># bad
e = M * c ** 2

# good
e = M * c**2</code></pre>
                      <p>Bir başka istisna da, rasyonel literallerin içindeki eğik çizgi:</p>
                      <pre><code class="language-ruby"># bad
o_scale = 1 / 48r

# good
o_scale = 1/48r</code></pre>
                      <p>Diğer bir istisna, güvenli navigasyon operatörüdür:</p>
                      <pre><code class="language-ruby"># bad
foo &. bar
foo &.bar
foo&. bar

# good
foo&.bar</code></pre>
                    </li>
                    <li>
                      <p>Köşeli parantezlerde boşluk kullanmayın. Süslü parantezlerde boşluk kullanın.</p>
                      <pre><code class="language-ruby"># bad
some( arg ).other
[ 1, 2, 3 ].each{|e| puts e}

# good
some(arg).other
[1, 2, 3].each { |e| puts e }</code></pre>
                      <p><code>{</code> ve <code>}</code> blok, çırpı (hash) ve dize interpolasyonu için kullanıldığından biraz daha açıklamayı hak ediyor. Çırpı için iki stil kabul edilebilir sayılır. İkinci seçenek, blok ve çırpı arasında görsel fark ekleme avantajına sahiptir. Hangisini seçerseniz seçin - tutarlı bir şekilde uygulayın.</p>
                      <pre><code class="language-ruby"># good - space after { and before }
{ one: 1, two: 2 }

# good - no space after { and before }
{one: 1, two: 2}</code></pre>
                      <p>İnterpolasyonlu ifadelerde, parantezlerin içinde boşluk olmamalıdır.</p>
                      <pre><code class="language-ruby"># bad
"From: #{ user.first_name }, #{ user.last_name }"

# good
"From: #{user.first_name}, #{user.last_name}"</code></pre>
                    </li>
                    <li>
                      <p><code>!</code> işaretinden sonra boşluk kullanmayın.</p>
                      <pre><code class="language-ruby"># bad
! something

# good
!something</code></pre>
                    </li>
                    <li>
                      <p>Aralık literalleri içinde boşluk kullanmayın.</p>
                      <pre><code class="language-ruby"># bad
1 .. 3
'a' ... 'z'

# good
1..3
'a'...'z'</code></pre>
                    </li>
                    <li>
                      <p><code>when</code>, <code>case</code> kadar derin olmalıdır. Hem "The Ruby Programming Language" hem de "Programming Ruby" de oluşturulan stil budur. Tarihsel olarak, <code>case</code> ve <code>switch</code> ifadelerinin blok olmadığı gerçeğinden kaynaklanmaktadır, bu nedenle girintili olmamalıdır.</p>
                      <pre><code class="language-ruby"># bad
case
  when song.name == 'Misty'
    puts 'Not again!'
  when song.duration > 120
    puts 'Too long!'
  when Time.now.hour > 21
    puts "It's too late"
  else
    song.play
end

# good
case
when song.name == 'Misty'
  puts 'Not again!'
when song.duration > 120
  puts 'Too long!'
when Time.now.hour > 21
  puts "It's too late"
else
  song.play
end</code></pre>
                    </li>
                    <li>
                      <p>Koşullu bir ifadenin sonucunu bir değişkene atadığınızda, dalların normal hizalamasını koruyun.</p>
                      <pre><code class="language-ruby"># bad - pretty convoluted
kind = case year
when 1850..1889 then 'Blues'
when 1890..1909 then 'Ragtime'
when 1910..1929 then 'New Orleans Jazz'
when 1930..1939 then 'Swing'
when 1940..1950 then 'Bebop'
else 'Jazz'
end

result = if some_cond
  calc_something
else
  calc_something_else
end

# good - it's apparent what's going on
kind = case year
       when 1850..1889 then 'Blues'
       when 1890..1909 then 'Ragtime'
       when 1910..1929 then 'New Orleans Jazz'
       when 1930..1939 then 'Swing'
       when 1940..1950 then 'Bebop'
       else 'Jazz'
       end

result = if some_cond
           calc_something
         else
           calc_something_else
         end

# good (and a bit more width efficient)
kind =
  case year
  when 1850..1889 then 'Blues'
  when 1890..1909 then 'Ragtime'
  when 1910..1929 then 'New Orleans Jazz'
  when 1930..1939 then 'Swing'
  when 1940..1950 then 'Bebop'
  else 'Jazz'
  end

result =
  if some_cond
    calc_something
  else
    calc_something_else
  end</code></pre>
                    </li>
                    <li>
                      <p>Yöntem tanımları arasında ve ayrıca yöntemleri dahili olarak mantıksal paragraflara ayırmak için boş satırlar kullanın.</p>
                      <pre><code class="language-ruby">def some_method
  data = initialize(options)

  data.manipulate!

  data.result
end

def some_method
  result
end</code></pre>
                    </li>
                    <li>
                      <p>Üst üste birkaç boş satır kullanmayın.</p>
                      <pre><code class="language-ruby"># bad - It has two empty lines.
some_method


some_method

# good
some_method

some_method</code></pre>
                    </li>
                    <li>
                      <p>Erişim belirteçlerinde boş satır kullanın.</p>
                      <pre><code class="language-ruby"># bad
class Foo
  attr_reader :foo
  def foo
    # do something...
  end
end

# good
class Foo
  attr_reader :foo

  def foo
    # do something...
  end
end</code></pre>
                    </li>
                    <li>
                      <p>Yöntem, sınıf, modül ve blok gövdelerinin etrafında boş satır kullanmayın.</p>
                      <pre><code class="language-ruby"># bad
class Foo

  def foo

    begin

      do_something do

        something

      end

    rescue

      something

    end

  end

end

# good
class Foo
  def foo
    begin
      do_something do
        something
      end
    rescue
      something
    end
  end
end</code></pre>
                    </li>
                    <li>
                      <p>Bir yöntem çağrısında, özellikle parametreler ayrı satırlarda olmadığında, son parametreden sonra virgülten kaçının.</p>
                      <pre><code class="language-ruby"># bad - easier to move/add/remove parameters, but still not preferred
some_method(
  size,
  count,
  color,
)

# bad
some_method(size, count, color, )

# good
some_method(size, count, color)</code></pre>
                    </li>
                    <li>
                      <p>Yöntem parametrelerine varsayılan değer atarken <code>=</code> işlecinin etrafında boşluk kullanın:</p>
                      <pre><code class="language-ruby"># bad
def some_method(arg1=:default, arg2=nil, arg3=[])
  # do something...
end

# good
def some_method(arg1 = :default, arg2 = nil, arg3 = [])
  # do something...
end</code></pre>
                      <p>Birkaç Ruby kitabı birinci stili önerirken, ikincisi pratikte daha belirgindir (ve tartışmalı olarak biraz daha okunaklıdır).</p>
                    </li>
                    <li>
                      <p>Gerekmiyorsa satırı devam ettirmekten kaçının. Uygulamada, dize bitiştirme dışında bir şey için kullanmayın.</p>
                      <pre><code class="language-ruby"># bad
result = 1 - \
         2

# good (but still ugly as hell)
result = 1 \
         - 2

long_string = 'First part of the long string' \
              ' and second part of the long string'</code></pre>
                    </li>
                    <li>
                      <p>Tutarlı bir çok satırlı yöntem zincirleme stili benimseyin. Ruby topluluğunda, ikisi de iyi uygulama olarak görülen iki popüler stil vardır.</p>
                      <ul>
                        <li>
                          <p><b>(Seçenek A)</b> Başka bir satırda zincirleme yöntem çağrısı devam ederken, <code>.</code> 'yı ikinci satırda tutun.</p>
                          <pre><code class="language-ruby"># bad - need to consult first line to understand second line
one.two.three.
  four

# good - it's immediately clear what's going on the second line
one.two.three
  .four</code></pre>
                        </li>
                        <li>
                          <p><b>(Seçenek B)</b> Zincirleme yöntem çağrısı başka bir satıra devam ederken, ifadenin devam ettiğini belirtmek için ilk satıra <code>.</code> ekleyin.</p>
                          <pre><code class="language-ruby"># bad - need to read ahead to the second line to know that the chain continues
one.two.three
  .four

# good - it's immediately clear that the expression continues beyond the first line
one.two.three.
  four</code></pre>
                        </li>
                      </ul>
                    </li>
                    <li>
                      <p>Birden fazla satıra yayılan yöntem parametrelerini hizalayın. Satır uzunluğu kısıtlamaları nedeniyle parametreleri hizalamak uygun olmadığında, ilk satırdan sonra satırlar için tek girinti de kabul edilebilir.</p>
                      <pre><code class="language-ruby"># starting point (line is too long)
def send_mail(source)
  Mailer.deliver(to: 'bob@example.com', from: 'us@example.com', subject: 'Important message', body: source.text)
end

# bad (double indent)
def send_mail(source)
  Mailer.deliver(
      to: 'bob@example.com',
      from: 'us@example.com',
      subject: 'Important message',
      body: source.text)
end

# good
def send_mail(source)
  Mailer.deliver(to: 'bob@example.com',
                 from: 'us@example.com',
                 subject: 'Important message',
                 body: source.text)
end

# good (normal indent)
def send_mail(source)
  Mailer.deliver(
    to: 'bob@example.com',
    from: 'us@example.com',
    subject: 'Important message',
    body: source.text
  )
end</code></pre>
                    </li>
                    <li>
                      <p>Birden fazla satır içeren dizi öğelerini hizalayın.</p>
                      <pre><code class="language-ruby"># bad - single indent
menu_item = %w[Spam Spam Spam Spam Spam Spam Spam Spam
  Baked beans Spam Spam Spam Spam Spam]

# good
menu_item = %w[
  Spam Spam Spam Spam Spam Spam Spam Spam
  Baked beans Spam Spam Spam Spam Spam
]

# good
menu_item =
  %w[Spam Spam Spam Spam Spam Spam Spam Spam
     Baked beans Spam Spam Spam Spam Spam]</code></pre>
                    </li>
                    <li>
                      <p>Okunabilirliği artırmak için büyük sayısal literallere alt çizgi ekleyin.</p>
                      <pre><code class="language-ruby"># bad - how many 0s are there?
num = 1000000

# good - much easier to parse for the human brain
num = 1_000_000</code></pre>
                    </li>
                    <li>
                      <p>Sayısal literal önekleri için küçük harfleri tercih edin. Sekizlik için <code>0o</code>, onaltılık için <code>0x</code> ve ikili için <code>0b</code>. Ondalık literaller için <code>0d</code> öneki kullanmayın.</p>
                      <pre><code class="language-ruby"># bad
num = 01234
num = 0O1234
num = 0X12AB
num = 0B10101
num = 0D1234
num = 0d1234

# good - easier to separate digits from the prefix
num = 0o1234
num = 0x12AB
num = 0b10101
num = 1234</code></pre>
                    </li>
                    <li>
                      <p>API dokümantasyonu için <a href="https://yardoc.org/" rel="nofollow" target="blank">YARD</a> ve kurallarını kullanın.</p>
                    </li>
                    <li>
                      <p>Satırları 80 karakterle sınırlayın.</p>
                    </li>
                    <li>
                      <p>Satırların sonunda fazladan boşluk bırakmaktan kaçının.</p>
                    </li>
                    <li>
                      <p>Her dosyayı yeni satır karakteriyle bitirin. Yeni satır karakteriyle bitmeyen satırlar gerçek satır sayılmaz ve dosyanın son satırı işlenirken sorun yaşanabilir.</p>
                    </li>
                    <li>
                      <p>Blok yorumları kullanmayın. Boşluklardan önce gelemezler ve sıradan yorumlar kadar kolay farkedilmezler.</p>
                      <pre><code class="language-ruby"># bad
=begin
comment line
another comment line
=end

# good
# comment line
# another comment line</code></pre>
                    </li>
                  </ul>
                </section>
                <!-- / source code layout -->

                <!-- syntax -->
                <section id="section-2">
                  <h2 class="section-title-2">Sözdizimi <a data-scroll href="#section-2" class="anchor" data-toggle="tooltip" data-placement="top" title="Linki kopyala"><i class="icon-hash"></i></a></h2>
                  <ul>
                    <li>
                      <p><code>::</code> operatörünü yalnızca sabitlere (sınıflar ve modüller) ve kuruculara (<code>Array()</code> veya <code>Nokogiri::HTML()</code> gibi) başvurmak için kullanın. Yöntem çağrıları için kullanmayın.</p>
                      <pre><code class="language-ruby"># bad
SomeClass::some_method
some_object::some_method

# good
SomeClass.some_method
some_object.some_method
SomeModule::SomeClass::SOME_CONST
SomeModule::SomeClass()</code></pre>
                    </li>
                    <li>
                      <p>Sınıf yöntemlerini tanımlamak için <code>::</code> kullanmayın.</p>
                      <pre><code class="language-ruby"># bad
class Foo
  def self::some_method
  end
end

# good
class Foo
  def self.some_method
  end
end</code></pre>
                    </li>
                    <li>
                      <p>Fonksiyon parametre alacaksa <code>def</code> ile beraber parantez kullanın. Yöntem herhangi bir parametreyi kabul etmediğinde parantezleri atlayın.</p>
                      <pre><code class="language-ruby"># bad
def some_method()
  # body omitted
end

# good
def some_method
  # body omitted
end

# bad
def some_method_with_parameters param1, param2
  # body omitted
end

# good
def some_method_with_parameters(param1, param2)
  # body omitted
end</code></pre>
                    </li>
                    <li>
                      <p>Özellikle ilk parametre açık bir parantezle başlıyorsa - <code>f((3 + 2) + 1)</code>'de olduğu gibi - yöntem parametrelerinin çevresinde parantez kullanın.
</p>
                      <pre><code class="language-ruby"># bad
x = Math.sin y
# good
x = Math.sin(y)

# bad
array.delete e
# good
array.delete(e)

# bad
temperance = Person.new 'Temperance', 30
# good
temperance = Person.new('Temperance', 30)</code></pre>
                      <p>Her zaman parantezleri atlayacağınız durumlar</p>
                      <ul>
                        <li>
                          <p>Yöntem hiçbir parametre olmadan çağırıldığında:</p>
                          <pre><code class="language-ruby"># bad
Kernel.exit!()
2.even?()
fork()
'test'.upcase()

# good
Kernel.exit!
2.even?
fork
'test'.upcase</code></pre>
                        </li>
                        <li>
                          <p>Dahili bir DSL’in parçası olan yöntemler (Örneğin, Rake, Rails, RSpec):</p>
                          <pre><code class="language-ruby"># bad
validates(:name, presence: true)
# good
validates :name, presence: true</code></pre>
                        </li>
                        <li>
                          <p>Ruby'de "anahtar kelime" statüsüne sahip yöntemler:</p>
                          <pre><code class="language-ruby">class Person
  # bad
  attr_reader(:name, :age)
  # good
  attr_reader :name, :age

  # body omitted
end</code></pre>
                        </li>
                      </ul>
                      <p>Parantezleri atlayabileceğiniz durumlar</p>
                      <ul>
                        <li>
                          <p>Ruby'de "anahtar kelime" statüsüne sahip, ancak bildirimde bulunmayan yöntemler:</p>
                          <pre><code class="language-ruby"># good
puts(temperance.age)
system('ls')
# also good
puts temperance.age
system 'ls'</code></pre>
                        </li>
                      </ul>
                    </li>
                    <li>
                      <p>İsteğe bağlı parametreleri, parametre listesinin sonunda tanımlayın. Listenin önünde isteğe bağlı parametreleri olan yöntemleri çağırdığınızda, Ruby beklenmedik sonuçlar verebilir.</p>
                      <pre><code class="language-ruby"># bad
def some_method(a = 1, b = 2, c, d)
  puts "#{a}, #{b}, #{c}, #{d}"
end

some_method('w', 'x') # => '1, 2, w, x'
some_method('w', 'x', 'y') # => 'w, 2, x, y'
some_method('w', 'x', 'y', 'z') # => 'w, x, y, z'

# good
def some_method(c, d, a = 1, b = 2)
  puts "#{a}, #{b}, #{c}, #{d}"
end

some_method('w', 'x') # => '1, 2, w, x'
some_method('w', 'x', 'y') # => 'y, 2, w, x'
some_method('w', 'x', 'y', 'z') # => 'y, z, w, x'</code></pre>
                    </li>
                    <li>
                      <p>Boolean parametreleri bir yönteme iletirken anahtar kelime parametrelerini kullanın.</p>
                      <pre><code class="language-ruby"># bad
def some_method(bar = false)
  puts bar
end

# bad - common hack before keyword args were introduced
def some_method(options = {})
  bar = options.fetch(:bar, false)
  puts bar
end

# good
def some_method(bar: false)
  puts bar
end

some_method            # => false
some_method(bar: true) # => true</code></pre>
                    </li>
                    <li>
                      <p>İsteğe bağlı parametreler yerine anahtar kelime parametreleri tercih edin.</p>
                      <pre><code class="language-ruby"># bad
def some_method(a, b = 5, c = 1)
  # body omitted
end

# good
def some_method(a, b: 5, c: 1)
  # body omitted
end</code></pre>
                    </li>
                    <li>
                      <p>Çırpı (hash) yerine anahtar kelime parametreleri kullanın.</p>
                      <pre><code class="language-ruby"># bad
def some_method(options = {})
  bar = options.fetch(:bar, false)
  puts bar
end

# good
def some_method(bar: false)
  puts bar
end</code></pre>
                    </li>
                    <li>
                      <p>Değişkenleri tanımlamak için paralel atama kullanmaktan kaçının. Paralel atama, splat(*) operatörüyle birlikte kullanılan bir yöntem çağrısının dönüşü için veya değişken atamasını değiştirmek için kullanılabilir. Paralel atama, ayrı atamalar kadar rahat okunamaz.</p>
                      <pre><code class="language-ruby"># bad
a, b, c, d = 'foo', 'bar', 'baz', 'foobar'

# good
a = 'foo'
b = 'bar'
c = 'baz'
d = 'foobar'

# good - swapping variable assignment
# Swapping variable assignment is a special case because it will allow you to
# swap the values that are assigned to each variable.
a = 'foo'
b = 'bar'

a, b = b, a
puts a # => 'bar'
puts b # => 'foo'

# good - method return
def multi_return
  [1, 2]
end

first, second = multi_return

# good - use with splat
first, *list = [1, 2, 3, 4] # first => 1, list => [2, 3, 4]

hello_array = *'Hello' # => ["Hello"]

a = *(1..3) # => [1, 2, 3]</code></pre>
                    </li>
                    <li>
                      <p>Tam olarak nedenini bilmiyorsanız, <code>for</code> kullanmayın. Çoğu zaman bunun yerine yineleyiciler kullanılmalıdır.</p>
                      <pre><code class="language-ruby">arr = [1, 2, 3]

# bad
for elem in arr do
  puts elem
end

# note that elem is accessible outside of the for loop
elem # => 3

# good
arr.each { |elem| puts elem }

# elem is not accessible outside each's block
elem # => NameError: undefined local variable or method `elem'</code></pre>
                    </li>
                    <li>
                      <p>Çok satırlı <code>if/unless</code> için <code>then</code> kullanmayın.</p>
                      <pre><code class="language-ruby"># bad
if some_condition then
  # body omitted
end

# good
if some_condition
  # body omitted
end</code></pre>
                    </li>
                    <li>
                      <p>Üçlü işleci <code>if/then/else/end</code> yapıları üzerinden kullanın. Daha yaygın ve tabii ki daha özlü.</p>
                      <pre><code class="language-ruby"># bad
result = if some_condition then something else something_else end

# good
result = some_condition ? something : something_else</code></pre>
                    </li>
                    <li>
                      <p>Üçlü bir işleçte dal başına bir ifade kullanın. Bu aynı zamanda üçlü operatörlerin iç içe geçmemesi gerektiği anlamına gelir. Bu durumlarda <code>if/else</code> yapıları tercih edilir.</p>
                      <pre><code class="language-ruby"># bad
some_condition ? (nested_condition ? nested_something : nested_something_else) : something_else

# good
if some_condition
  nested_condition ? nested_something : nested_something_else
else
  something_else
end</code></pre>
                    </li>
                    <li>
                      <p><code>if x; ...</code> kullanmayın. Bunun yerine üçlü operatörü kullanın.</p>
                      <pre><code class="language-ruby"># bad
result = if some_condition; something else something_else end

# good
result = some_condition ? something : something_else</code></pre>
                    </li>
                    <li>
                      <p><code>if</code> ve <code>case</code> ifadelerinin sonuç döndüren ifadeler olduğu gerçeğinden faydalanın.</p>
                      <pre><code class="language-ruby"># bad
if condition
  result = x
else
  result = y
end

# good
result =
  if condition
    x
  else
    y
  end</code></pre>
                    </li>
                    <li>
                      <p>Tek satırlı durumlar için <code>when x then ...</code> kullanın. Alternatif sözdizimi <code>when x: ...</code> Ruby 1.9'dan itibaren kaldırılmıştır.</p>
                    </li>
                    <li>
                      <p><code>when x; ...</code> kullanmayın. Önceki kurala bakınız.</p>
                    </li>
                    <li>
                      <p><code>not</code> yerine <code>!</code> kullanın.</p>
                      <pre><code class="language-ruby"># bad - parentheses are required because of op precedence
x = (not something)

# good
x = !something</code></pre>
                    </li>
                    <li>
                      <p><code>!!</code> kullanmaktan kaçının.</p>
                      <p><code>!!</code> bir değeri boolean'a dönüştürür, ancak kontrol ifadesi koşulunda bu açık dönüşüme ihtiyacınız yoktur. <code>nil</code> kontrolü yapmak istiyorsanız, bunun yerine <code>nil?</code> kullanın.</p>
                      <pre><code class="language-ruby"># bad
x = 'test'
# obscure nil check
if !!x
  # body omitted
end

# good
x = 'test'
if x
  # body omitted
end</code></pre>
                    </li>
                    <li>
                      <p><code>and</code> and <code>or</code> anahtar kelimelerini kullanmayın.</p>
                      <pre><code class="language-ruby"># bad
# boolean expression
ok = got_needed_arguments and arguments_are_valid

# control flow
document.save or raise("Failed to save document!")

# good
# boolean expression
ok = got_needed_arguments && arguments_are_valid

# control flow
raise("Failed to save document!") unless document.save

# ok
# control flow
document.save || raise("Failed to save document!")</code></pre>
                    </li>
                    <li>
                      <p>Çok satırlı <code>?:</code> (Üçlü operatör) kullanmak yerine <code>if/unless</code> kullanın.</p>
                    </li>
                    <li>
                      <p>Tek satırlı bir gövdeye sahipseniz, <code>if/unless</code> değiştiricisini kullanın. Diğer bir iyi alternatif, kontrol akışının <code>&&/||</code> kullanılmasıdır.</p>
                      <pre><code class="language-ruby"># bad
if some_condition
  do_something
end

# good
do_something if some_condition

# another good option
some_condition && do_something</code></pre>
                    </li>
                    <li>
                      <p>Çok satırlı bir bloğun sonunda <code>if/unless</code> kullanmaktan kaçının.</p>
                      <pre><code class="language-ruby"># bad
10.times do
  # multi-line body omitted
end if some_condition

# good
if some_condition
  10.times do
    # multi-line body omitted
  end
end</code></pre>
                    </li>
                    <li>
                      <p>İç içe <code>if/unless/while/until</code> kullanımından kaçının. Eğer uygunsa <code>&&/||</code> kullanın.</p>
                      <pre><code class="language-ruby"># bad
do_something if other_condition if some_condition

# good
do_something if some_condition && other_condition</code></pre>
                    </li>
                    <li>
                      <p>Olumsuz koşullar için <code>if</code> yerine <code>unless</code> kullanın (veya kontrol akışı <code>||</code>).</p>
                      <pre><code class="language-ruby"># bad
do_something if !some_condition

# bad
do_something if not some_condition

# good
do_something unless some_condition

# another good option
some_condition || do_something</code></pre>
                    </li>
                    <li>
                      <p><code>unless</code> ile birlikte <code>else</code> kullanmayın. Bunları pozitif durumu öne alarak tekrar yazın.</p>
                      <pre><code class="language-ruby"># bad
unless success?
  puts 'failure'
else
  puts 'success'
end

# good
if success?
  puts 'success'
else
  puts 'failure'
end</code></pre>
                    </li>
                    <li>
                      <p>Kontrol ifadesinin koşulu etrafında parantez kullanmayın.</p>
                      <pre><code class="language-ruby"># bad
if (x > 10)
  # body omitted
end

# good
if x > 10
  # body omitted
end</code></pre>
                    </li>
                    <li>
                      <p>Çok satırlı <code>while/until</code> için <code>while/until condition do</code> kullanmayın.</p>
                      <pre><code class="language-ruby"># bad
while x > 5 do
  # body omitted
end

until x > 5 do
  # body omitted
end

# good
while x > 5
  # body omitted
end

until x > 5
  # body omitted
end</code></pre>
                    </li>
                    <li>
                      <p>Tek satırlı bir gövdeye sahip olduğunuzda <code>while/until</code> kullanımını değiştirin.</p>
                      <pre><code class="language-ruby"># bad
while some_condition
  do_something
end

# good
do_something while some_condition</code></pre>
                    </li>
                    <li>
                      <p>Olumsuz koşullar için <code>while</code> yerine <code>until</code> kullanın.</p>
                      <pre><code class="language-ruby"># bad
do_something while !some_condition

# good
do_something until some_condition</code></pre>
                    </li>
                    <li>
                      <p>Sonsuz bir döngüye ihtiyaç duyduğunuzda, <code>while/until</code> yerine <code>Kernel#loop</code> döngüsünü kullanın.</p>
                      <pre><code class="language-ruby"># bad
while true
  do_something
end

until false
  do_something
end

# good
loop do
  do_something
end</code></pre>
                    </li>
                    <li>
                      <p>Döngü sonundaki testler için <code>begin/end/until</code> veya <code>begin/end/while</code> yerine <code>Kernel#loop</code> ile birlikte <code>break</code> kullanın.</p>
                      <pre><code class="language-ruby"># bad
begin
  puts val
  val += 1
end while val < 0

# good
loop do
  puts val
  val += 1
  break unless val < 0
end</code></pre>
                    </li>
                    <li>
                      <p>Hash parametreler için dıştaki parantezleri atlayın.</p>
                      <pre><code class="language-ruby"># bad
user.set({ name: 'John', age: 45, permissions: { read: true } })

# good
user.set(name: 'John', age: 45, permissions: { read: true })</code></pre>
                    </li>
                    <li>
                      <p>Dahili bir DSL'in parçası olan yöntemler için iç ve dış parantezleri atlayın.</p>
                      <pre><code class="language-ruby">class Person < ActiveRecord::Base
  # bad
  validates(:name, { presence: true, length: { within: 1..10 } })

  # good
  validates :name, presence: true, length: { within: 1..10 }
end</code></pre>
                    </li>
                    <li>
                      <p>Çağrılan yöntem bir bloğun tek işlemi olduğunda proc çağırma kısayolunu kullanın.</p>
                      <pre><code class="language-ruby"># bad
names.map { |name| name.upcase }

# good
names.map(&:upcase)</code></pre>
                    </li>
                    <li>
                      <p>Tek satırlı bloklar için <code>do...end</code> yerine <code>{...}</code> tercih edin. Çok satırlı bloklar için <code>{...}</code> kullanmaktan kaçının. Her zaman "kontrol akışı" ve "yöntem tanımları" için <code>do...end</code> kullanın (Örneğin, Rakefiles ve belirli DSL'lerde). Zincirleme yöntemleri kullanırken <code>do...end</code>'den kaçının.</p>
                      <pre><code class="language-ruby">names = %w[Bozhidar Steve Sarah]

# bad
names.each do |name|
  puts name
end

# good
names.each { |name| puts name }

# bad
names.select do |name|
  name.start_with?('S')
end.map { |name| name.upcase }

# good
names.select { |name| name.start_with?('S') }.map(&:upcase)</code></pre>
                    </li>
                    <li>
                      <p>Akış kontrölü için gerekli olmadığında <code>return</code> kullanmaktan kaçının.</p>
                      <pre><code class="language-ruby"># bad
def some_method(some_arr)
  return some_arr.size
end

# good
def some_method(some_arr)
  some_arr.size
end</code></pre>
                    </li>
                    <li>
                      <p>Gerekli olmadığında <code>self</code> kullanmaktan kaçının.</p>
                      <pre><code class="language-ruby"># bad
def ready?
  if self.last_reviewed_at > self.last_updated_at
    self.worker.update(self.content, self.options)
    self.status = :in_progress
  end
  self.status == :verified
end

# good
def ready?
  if last_reviewed_at > last_updated_at
    worker.update(content, options)
    self.status = :in_progress
  end
  status == :verified
end</code></pre>
                    </li>
                    <li>
                      <p>Sonuç olarak, ikisi de eşit olmadıkça iç kapsamda tanımlanan değişkenin, dış kapsamdaki değişkeni gölgelemesinden kaçının.</p>
                      <pre><code class="language-ruby">class Foo
  attr_accessor :options

  # ok
  def initialize(options)
    self.options = options
    # both options and self.options are equivalent here
  end

  # bad
  def do_something(options = {})
    unless options[:when] == :later
      output(self.options[:message])
    end
  end

  # good
  def do_something(params = {})
    unless params[:when] == :later
      output(options[:message])
    end
  end
end</code></pre>
                    </li>
                    <li>
                      <p>Koşullu ifadelerde <code>=</code> (atama) dönüş değerini parantez içine almadan kullanmayın. Bu, koşullu ifade içinde güvenli atama olarak adlandırılan Rubyistler arasında oldukça popüler bir deyimdir.</p>
                      <pre><code class="language-ruby"># bad (+ a warning)
if v = array.grep(/foo/)
  do_something(v)
  # some code
end

# good (MRI would still complain, but RuboCop won't)
if (v = array.grep(/foo/))
  do_something(v)
  # some code
end

# good
v = array.grep(/foo/)
if v
  do_something(v)
  # some code
end</code></pre>
                    </li>
                    <li>
                      <p>Uygulanabilir olduğunda kendiliğinden atamalı operatörleri kullanın.</p>
                      <pre><code class="language-ruby"># bad
x = x + y
x = x * y
x = x**y
x = x / y
x = x || y
x = x && y

# good
x += y
x *= y
x **= y
x /= y
x ||= y
x &&= y</code></pre>
                    </li>
                    <li>
                      <p>Henüz başlatılmamış değişkenleri başlatmak için <code>||=</code> kullanın.</p>
                      <pre><code class="language-ruby"># bad
name = name ? name : 'Bozhidar'

# bad
name = 'Bozhidar' unless name

# good - set name to 'Bozhidar', only if it's nil or false
name ||= 'Bozhidar'</code></pre>
                    </li>
                    <li>
                      <p>Boolean değişkenleri başlatmak için <code>||=</code> kullanmayın. (Mevcut değer <code>false</code> ise, ne olacağını düşünün.)
</p>
                      <pre><code class="language-ruby"># bad - would set enabled to true even if it was false
enabled ||= true

# good
enabled = true if enabled.nil?</code></pre>
                    </li>
                    <li>
                      <p>Var olan veya olmayan değişkenleri önceden işlemek için <code>&&=</code> kullanın. <code>&&=</code> kullanmak, değeri yalnızca mevcutsa değiştirecek ve varlığını <code>if</code> ile kontrol etme ihtiyacını ortadan kaldıracaktır.</p>
                      <pre><code class="language-ruby"># bad
if something
  something = something.downcase
end

# bad
something = something ? something.downcase : nil

# ok
something = something.downcase if something

# good
something = something && something.downcase

# better
something &&= something.downcase</code></pre>
                    </li>
                    <li>
                      <p>Durum eşitliği işlecinin <code>===</code> açıkça kullanılmasından kaçının. Adından da anlaşılacağı gibi <code>case</code> ifadeleri ile örtük olarak kullanılması amaçlanmıştır ve bunların dışında oldukça kafa karıştırıcı kodlar verir.</p>
                      <pre><code class="language-ruby"># bad
Array === something
(1..100) === 7
/something/ === some_string

# good
something.is_a?(Array)
(1..100).include?(7)
some_string.match?(/something/)</code></pre>
                    </li>
                    <li>
                      <p><code>==</code> kullanabileceğiniz yerlerde <code>eql?</code> kullanmayın. <code>eql?</code> tarafından sağlanan daha katı karşılaştırma semantiğine pratikte nadiren ihtiyaç duyulur.</p>
                      <pre><code class="language-ruby"># bad - eql? is the same as == for strings
'ruby'.eql? some_str

# good
'ruby' == some_str
1.0.eql? x # eql? makes sense here if want to differentiate between Integer and Float 1</code></pre>
                    </li>
                    <li>
                      <p>Perl tarzı özel değişkenler kullanmaktan kaçının ($:, $; vb.).</p>
                      <pre><code class="language-ruby"># bad
$:.unshift File.dirname(__FILE__)

# good
require 'English'
$LOAD_PATH.unshift File.dirname(__FILE__)</code></pre>
                    </li>
                    <li>
                      <p>Yöntem adı ile açılış parantezi arasına boşluk koymayın.</p>
                      <pre><code class="language-ruby"># bad
f (3 + 2) + 1

# good
f(3 + 2) + 1</code></pre>
                    </li>
                    <li>
                      <p>Ruby yorumlayıcısını daima <code>-w</code> seçeneğiyle çalıştırın, böylece yukarıdaki kurallardan herhangi birini unutursanız sizi uyaracaktır!</p>
                    </li>
                    <li>
                      <p>Yöntemleri iç içe tanımlamayın, bunun yerine lambda kullanın.</p>
                      <pre><code class="language-ruby"># bad
def foo(x)
  def bar(y)
    # body omitted
  end

  bar(x)
end

# good - the same as the previous, but no bar redefinition on every foo call
def bar(y)
  # body omitted
end

def foo(x)
  bar(x)
end

# also good
def foo(x)
  bar = ->(y) { ... }
  bar.call(x)
end</code></pre>
                    </li>
                    <li>
                      <p>Tek satırlı gövde blokları için yeni lambda literal sözdizimini kullanın. Çok satırlı bloklar için <code>lambda</code> yöntemini kullanın.</p>
                      <pre><code class="language-ruby"># bad
l = lambda { |a, b| a + b }
l.call(1, 2)

# correct, but looks extremely awkward
l = ->(a, b) do
  tmp = a * 7
  tmp * b / 50
end

# good
l = ->(a, b) { a + b }
l.call(1, 2)

l = lambda do |a, b|
  tmp = a * 7
  tmp * b / 50
end</code></pre>
                    </li>
                    <li>
                      <p>Parametreli lambda tanımlarken parantezleri atlamayın.</p>
                      <pre><code class="language-ruby"># bad
l = ->x, y { something(x, y) }

# good
l = ->(x, y) { something(x, y) }</code></pre>
                    </li>
                    <li>
                      <p>Parametresiz lambda tanımlarken parantezleri kullanmayın.</p>
                      <pre><code class="language-ruby"># bad
l = ->() { something }

# good
l = -> { something }</code></pre>
                    </li>
                    <li>
                      <p><code>Proc.new</code> yerine <code>proc</code>'u tercih edin.</p>
                      <pre><code class="language-ruby"># bad
p = Proc.new { |n| puts n }

# good
p = proc { |n| puts n }</code></pre>
                    </li>
                    <li>
                      <p><code>proc[]</code> veya <code>proc.()</code> yerine <code>proc.call()</code> kullanın.</p>
                      <pre><code class="language-ruby"># bad - looks similar to Enumeration access
l = ->(v) { puts v }
l[1]

# also bad - uncommon syntax
l = ->(v) { puts v }
l.(1)

# good
l = ->(v) { puts v }
l.call(1)</code></pre>
                    </li>
                    <li>
                      <p><code>_</code> karakteri kullanılmayan blok parametreleri ve yerel değişkenlerin önekidir. Sadece <code>_</code> kullanmak da kabul edilebilir (biraz daha az açıklayıcı olmasına rağmen). Bu kural Ruby yorumlayıcısı ve RuboCop gibi araçlar tarafından tanınır ve kullanılmayan değişken uyarılarını bastırır.</p>
                      <pre><code class="language-ruby"># bad
result = hash.map { |k, v| v + 1 }

def something(x)
  unused_var, used_var = something_else(x)
  # some code
end

# good
result = hash.map { |_k, v| v + 1 }

def something(x)
  _unused_var, used_var = something_else(x)
  # some code
end

# good
result = hash.map { |_, v| v + 1 }

def something(x)
  _, used_var = something_else(x)
  # some code
end</code></pre>
                    </li>
                    <li>
                      <p><code>STDOUT/STDERR/STDIN</code> yerine <code>$stdout/$stderr/$stdin</code> kullanın. <code>STDOUT/STDERR/STDIN</code> sabittir ve Ruby'de sabitleri yeniden atanabilir (muhtemelen bazı akışı yeniden yönlendirmek için), bunu yaparsanız yorumlayıcı uyarısı alırsınız.</p>
                    </li>
                    <li>
                      <p><code>$stderr.puts</code> yerine <code>warn</code> kullanın. Daha özlü ve net olmanın yanı sıra, gerekirse uyarıları bastırmanıza izin verir.</p>
                    </li>
                    <li>
                      <p><code>String#%</code> yerine <code>sprintf</code> veya takma adı olan <code>format</code> kullanın.</p>
                      <pre><code class="language-ruby"># bad
'%d %d' % [20, 10]
# => '20 10'

# good
sprintf('%d %d', 20, 10)
# => '20 10'

# good
sprintf('%<first>d %<second>d', first: 20, second: 10)
# => '20 10'

format('%d %d', 20, 10)
# => '20 10'

# good
format('%<first>d %<second>d', first: 20, second: 10)
# => '20 10'</code></pre>
                    </li>
                    <li>
                      <p><code>Array#*</code> yerine <code>Array#join</code> kullanın.</p>
                      <pre><code class="language-ruby"># bad
%w[one two three] * ', '
# => 'one, two, three'

# good
%w[one two three].join(', ')
# => 'one, two, three'</code></pre>
                    </li>
                    <li>
                      <p>Bir değişkene dizi olarak değerlendirmek istediğinizde, ancak bu değişkenin dizi olduğundan emin olamadığınız durumlarda, açık <code>Array</code> denetimi veya <code>[*var]</code> yerine <code>Array()</code> kullanın. </p>
                      <pre><code class="language-ruby"># bad
paths = [paths] unless paths.is_a? Array
paths.each { |path| do_something(path) }

# bad (always creates a new Array instance)
[*paths].each { |path| do_something(path) }

# good (and a bit more readable)
Array(paths).each { |path| do_something(path) }</code></pre>
                    </li>
                    <li>
                      <p>Mümkün olduğunda karmaşık karşılaştırma mantığı yerine aralık <code>Comparable#between?</code> kullanın.</p>
                      <pre><code class="language-ruby"># bad
do_something if x >= 1000 && x <= 2000

# good
do_something if (1000..2000).include?(x)

# good
do_something if x.between?(1000, 2000)</code></pre>
                    </li>
                    <li>
                      <p><code>==</code> ile yapılan belirli karşılaştırmalar için yordam yöntemlerini tercih edin.</p>
                      <pre><code class="language-ruby"># bad
if x % 2 == 0
end

if x % 2 == 1
end

if x == nil
end

# good
if x.even?
end

if x.odd?
end

if x.nil?
end

if x.zero?
end

if x == 0
end</code></pre>
                    </li>
                    <li>
                      <p>Boolean değişkenler ile çalışmadığınız sürece, açıkça boş değişken kontrolü yapmayın.</p>
                      <pre><code class="language-ruby"># bad
do_something if !something.nil?
do_something if something != nil

# good
do_something if something

# good - dealing with a boolean
def value_set?
  !@some_boolean.nil?
end</code></pre>
                    </li>
                    <li>
                      <p><code>BEGIN</code> bloklarını kullanmaktan kaçının.</p>
                    </li>
                    <li>
                      <p><code>END</code> bloklarını kullanmayın. Bunun yerine <code>Kernel#at_exit</code> kullanın.</p>
                      <pre><code class="language-ruby"># bad
END { puts 'Goodbye!' }

# good
at_exit { puts 'Goodbye!' }</code></pre>
                    </li>
                    <li>
                      <p>Flip-Flop operatörü kullanmaktan kaçının.</p>
                    </li>
                    <li>
                      <p>Akış kontrolü için iç içe koşullu ifadeler kullanmaktan kaçının.</p>
                      <p></p>
                      <pre><code class="language-ruby"># bad
def compute_thing(thing)
  if thing[:foo]
    update_with_bar(thing[:foo])
    if thing[:foo][:bar]
      partial_compute(thing)
    else
      re_compute(thing)
    end
  end
end

# good
def compute_thing(thing)
  return unless thing[:foo]
  update_with_bar(thing[:foo])
  return re_compute(thing) unless thing[:foo][:bar]
  partial_compute(thing)
end</code></pre>
                      <p>Döngülerde, koşullu ifadeler yerine <code>next</code> kullanın.</p>
                      <pre><code class="language-ruby"># bad
[0, 1, 2, 3].each do |item|
  if item > 1
    puts item
  end
end

# good
[0, 1, 2, 3].each do |item|
  next unless item > 1
  puts item
end</code></pre>
                    </li>
                    <li>
                      <p><code>collect</code> yerine <code>map</code>, <code>detect</code> yerine <code>find</code>, <code>find_all</code> yerine <code>select</code>, <code>inject</code> yerine <code>reduce</code>, <code>length</code> yerine <code>size</code> kullanmayı tercih edin. Takma adların kullanımı okunabilirliği arttırır. </p>
                    </li>
                    <li>
                      <p><code>count</code> ifadesini <code>size</code> yerine kullanmayın. Dizi dışındaki nesnelerin boyutunu belirlemek için tüm koleksiyon yinelenir.</p>
                      <pre><code class="language-ruby"># bad
some_hash.count

# good
some_hash.size</code></pre>
                    </li>
                    <li>
                      <p><code>map + flatten</code> yerine <code>flat_map</code> kullanın. Bu durum 2'den büyük derinliğe sahip diziler için geçerli değildir, yani <code>users.first.songs == ['a', ['b','c']]</code> ise, o zaman <code>flat_map</code> yerine <code>map + flatten</code> kullanın. <code>flat_map</code> diziyi ilk katmana göre düzleştirir, oysa <code>flatten</code> tamamen düzleştirir.</p>
                      <pre><code class="language-ruby"># bad
all_songs = users.map(&:songs).flatten.uniq

# good
all_songs = users.flat_map(&:songs).uniq</code></pre>
                    </li>
                    <li>
                      <p><code>reverse.each</code> yerine <code>reverse_each</code> kullanmayı tercih edin çünkü <code>include Enumarable</code> içeren bazı sınıflar verimli bir uygulama sağlayacaktır. Bir sınıfın özel bir uygulama sağlamadığı en kötü durumda bile, <code>Enumerable</code>'dan devralınan genel uygulama en azından <code>reverse.each</code> kullanmak kadar verimli olacaktır.</p>
                      <pre><code class="language-ruby"># bad
array.reverse.each { ... }

# good
array.reverse_each { ... }</code></pre>
                    </li>
                  </ul>
                </section>
                <!-- / syntax -->

                <!-- naming -->
                <section id="section-3">
                  <h2 class="section-title-2">Adlandırma <a data-scroll href="#section-3" class="anchor" data-toggle="tooltip" data-placement="top" title="Linki kopyala"><i class="icon-hash"></i></a></h2>
                  <ul>
                    <li>
                      <p>İngilizce'deki ad tanımlayıcıları.</p>
                      <pre><code class="language-ruby"># bad - identifier using non-ascii characters
заплата = 1_000

# bad - identifier is a Bulgarian word, written with Latin letters (instead of Cyrillic)
zaplata = 1_000

# good
salary = 1_000</code></pre>
                    </li>
                    <li>
                      <p>Semboller, yöntemler ve değişkenler için <code>snake_case</code> kullanın.</p>
                      <pre><code class="language-ruby"># bad
:'some symbol'
:SomeSymbol
:someSymbol

someVar = 5

def someMethod
  # some code
end

def SomeMethod
  # some code
end

# good
:some_symbol

some_var = 5

def some_method
  # some code
end</code></pre>
                    </li>
                    <li>
                      <p>Rakamları semboller, yöntemler ve değişkenler üzerindeki harflerden ayırmayın.</p>
                      <pre><code class="language-ruby"># bad
:some_sym_1

some_var_1 = 1

var_10  = 10

def some_method_1
  # some code
end

# good
:some_sym1

some_var1 = 1

var10    = 10

def some_method1
  # some code
end</code></pre>
                    </li>
                    <li>
                      <p>Sınıflar ve modüller için <code>CamelCase</code> kullanın. (HTTP, RFC, XML gibi kısaltmaları büyük harf tutun.)</p>
                      <pre><code class="language-ruby"># bad
class Someclass
  # some code
end

class Some_Class
  # some code
end

class SomeXml
  # some code
end

class XmlSomething
  # some code
end

# good
class SomeClass
  # some code
end

class SomeXML
  # some code
end

class XMLSomething
  # some code
end</code></pre>
                    </li>
                    <li>
                      <p>Dosyaları adlandırmak için <code>snake_case</code> kullanın, örn. <code>hello_world.rb</code>.</p>
                    </li>
                    <li>
                      <p>Dizinleri adlandırmak için <code>snake_case</code> kullanın, örn. <code>lib/hello_world/hello_world.rb</code>.</p>
                    </li>
                    <li>
                      <p>Kaynak dosya başına sadece bir sınıf/modül olmasını hedefleyin. Dosya adını sınıf/modül olarak adlandırın, ancak <code>CamelCase</code>'i <code>snake_case</code> ile değiştirin.</p>
                    </li>
                    <li>
                      <p>Diğer sabitler için <code>SCREAMING_SNAKE_CASE</code> kullanın.</p>
                      <pre><code class="language-ruby"># bad
SomeConst = 5

# good
SOME_CONST = 5</code></pre>
                    </li>
                    <li>
                      <p>Boolean değer döndüren yönetemlerin adları (örn. Array#empty?) soru işareti ile bitmelidir.</p>
                    </li>
                    <li>
                      <p><code>is</code>, <code>does</code> veya <code>can</code> gibi yardımcı fiillerle yöntem adı kullanmaktan kaçının. Bu kelimeler gereksiz ve Ruby çekirdek kütüphanesindeki boolean yöntemlerin (<code>empty?</code> ve <code>include?</code> gibi) tarzı ile tutarsızdır.</p>
                      <pre><code class="language-ruby"># bad
class Person
  def is_tall?
    true
  end

  def can_play_basketball?
    false
  end

  def does_like_candy?
    true
  end
end

# good
class Person
  def tall?
    true
  end

  def basketball_player?
    false
  end

  def likes_candy?
    true
  end
end</code></pre>
                    </li>
                    <li>
                      <p>Potansiyel olarak tehlikeli yöntemlerin adları, bu tehlikeli yöntemin güvenli bir sürümü varsa, ünlem işareti ile bitmelidir.</p>
                      <pre><code class="language-ruby"># bad - there is no matching 'safe' method
class Person
  def update!
  end
end

# good
class Person
  def update
  end
end

# good
class Person
  def update!
  end

  def update
  end
end</code></pre>
                    </li>
                  </ul>
                </section>
                <!-- / naming -->

                <!-- comments -->
                <section id="section-4">
                  <h2 class="section-title-2">Yorumlar <a data-scroll href="#section-4" class="anchor" data-toggle="tooltip" data-placement="top" title="Linki kopyala"><i class="icon-hash"></i></a></h2>
                  <blockquote class="blockquote">
                    <p class="mb-1">İyi kod, kendi en iyi dökümantasyonudur. Bir yorum eklemek üzeresiniz, kendinize şu soruyu sorun: "Bu yoruma gerek kalmaması için kodu nasıl geliştirebilirim?" Kodu geliştirin ve daha net hale getirmek için belgeleyin.</p>
                    <footer class="blockquote-footer"><cite title="Source Title">Steve McConnell</cite></footer>
                  </blockquote>
                  <ul>
                    <li>
                      <p>Kendi kendini belgeleyen kod yazın ve bu bölümün geri kalanını yok sayın. Ciddi anlamda!</p>
                    </li>
                    <li>
                      <p>Kendi kendini belgeleyen kod yazamadığınız durumlarda, kodun arkasındaki mantığı açıklayan bir yorum ekleyin.</p>
                      <pre><code class="language-ruby"># bad

x = BuggyClass.something.dup

def compute_dependency_graph
  ...30 lines of recursive graph merging...
end

# good

# BuggyClass returns an internal object, so we have to dup it to modify it.
x = BuggyClass.something.dup

# This is algorithm 6.4(a) from Worf & Yar's _Amazing Graph Algorithms_ (2243).
def compute_dependency_graph
  ...30 lines of recursive graph merging...
end</code></pre>
                    </li>
                    <li>
                      <p>Yorumları İngilizce yazın.</p>
                    </li>
                    <li>
                      <p>Yorumun başındaki <code>#</code> karakteri ile yorum metni arasında bir boşluk kullanın.</p>
                    </li>
                    <li>
                      <p>Bir kelimeden daha uzun yorumlara büyük harfle başlanır ve noktalama işaretleri kullanılır.</p>
                    </li>
                    <li>
                      <p>Gereksiz yorumlardan kaçının.</p>
                      <pre><code class="language-ruby"># bad
counter += 1 # Increments counter by one.</code></pre>
                    </li>
                    <li>
                      <p>Mevcut yorumları güncel tutun. Eski bir yorum hiç yorum yapmamaktan daha kötüdür.</p>
                    </li>
                    <li>
                      <p>Kötü kodu açıklamak için yorum yazmaktan kaçının. Kendini açıklayıcı hale getirmek için kodu tekrar gözden geçirin.</p>
                      <pre><code class="language-ruby"></code></pre>
                    </li>
                  </ul>
                  <blockquote class="blockquote">
                    <p class="mb-1">İyi kod iyi bir şakaya benzer: açıklamaya gerek yoktur.</p>
                    <footer class="blockquote-footer"><cite title="Source Title">Russ Olsen</cite></footer>
                  </blockquote>
                  <h3 class="h4">Yorum Dipnotları</h3>
                  <ul>
                    <li>
                      <p>Ek açıklamalar genellikle ilgili kodun hemen üstündeki satıra yazılmalıdır.</p>
                    </li>
                    <li>
                      <p>Ek açıklama anahtar sözcüğünü iki nokta üst üste ve boşluk, ardından sorunu açıklayan bir not izler.</p>
                    </li>
                    <li>
                      <p>Sorunu tanımlamak için birden fazla satır gerekiyorsa, sonraki satırlar <code>#</code>'dan sonra üç boşluk girintili olmalıdır.</p>
                      <pre><code class="language-ruby">def bar
  # FIXME: This has crashed occasionally since v3.2.1. It may
  #   be related to the BarBazUtil upgrade.
  baz(:quux)
end</code></pre>
                    </li>
                    <li>
                      <p>Sorunun çok açık olduğu durumlarda, herhangi bir açıklamanın gereksiz olması durumunda, ek açıklamalar not olmadan ilgili satırın sonuna bırakılabilir. Bu kullanım kural değil istisna olmalıdır.</p>
                      <pre><code class="language-ruby">def bar
  sleep 100 # OPTIMIZE
end</code></pre>
                    </li>
                    <li>
                      <p>Daha sonraki bir tarihte eklenmesi gereken eksik özellikleri veya işlevleri not etmek için <code>TODO</code> kullanın.</p>
                    </li>
                    <li>
                      <p>Düzeltilmesi gereken bozuk kodu not etmek için <code>FIXME</code> kullanın.</p>
                    </li>
                    <li>
                      <p>Performans sorunlarına neden olabilecek yavaş veya verimsiz kodu not etmek için <code>OPTIMIZE</code> kullanın.</p>
                    </li>
                    <li>
                      <p>Şüpheli kodlama uygulamalarının kullanıldığı ve yeniden incelenmesi gereken yerlerde <code>HACK</code> kullanın.</p>
                    </li>
                    <li>
                      <p>Amaçlandığı şekilde çalıştığını doğrulamak için bakılması gereken herhangi bir şeyi <code>REVIEW</code> kullanarak not edin.</p>
                    </li>
                    <li>
                      <p>Uygun görmeniz durumunda diğer özel açıklama anahtar kelimelerini kullanın, ancak bunları projenizin <code>README</code> veya benzeri dökümanlarında belgelendiğinden emin olun.</p>
                    </li>
                  </ul>
                  <h3 class="h4">Sihirli Yorumlar</h3>
                  <ul>
                    <li>
                      <p>Sihirli yorumları, dosyadaki tüm kod ve yorumların üstüne yerleştirin.</p>
                      <pre><code class="language-ruby"># bad
# Some documentation about Person

# frozen_string_literal: true
class Person
end

# good
# frozen_string_literal: true

# Some documentation about Person
class Person
end</code></pre>
                    </li>
                    <li>
                      <p>Bir dosyada mevcut olduğunda, sihirli yorumları shebang'ların altına yerleştirin.</p>
                      <pre><code class="language-ruby"># bad
# frozen_string_literal: true
#!/usr/bin/env ruby

App.parse(ARGV)

# good
#!/usr/bin/env ruby
# frozen_string_literal: true

App.parse(ARGV)</code></pre>
                    </li>
                    <li>
                      <p>Birden fazlasına ihtiyacınız olursa her satıra bir sihirli yorum kullanın.</p>
                      <pre><code class="language-ruby"># bad
# -*- frozen_string_literal: true; encoding: ascii-8bit -*-

# good
# frozen_string_literal: true
# encoding: ascii-8bit</code></pre>
                    </li>
                    <li>
                      <p>Sihirli yorumları koddan ve yorumlardan boş bir satır ile ayırın.</p>
                      <pre><code class="language-ruby"># bad
# frozen_string_literal: true
# Some documentation for Person
class Person
  # Some code
end

# good
# frozen_string_literal: true

# Some documentation for Person
class Person
  # Some code
end</code></pre>
                    </li>
                  </ul>
                </section>
                <!-- / comments -->

                <!-- classes & modules -->
                <section id="section-5">
                  <h2 class="section-title-2">Sınıflar ve Modüller <a data-scroll href="#section-5" class="anchor" data-toggle="tooltip" data-placement="top" title="Linki kopyala"><i class="icon-hash"></i></a></h2>
                  <ul>
                    <li>
                      <p>Sınıf tanımlarınızda tutarlı bir yapı kullanın.</p>
                      <pre><code class="language-ruby">class Person
  # extend and include go first
  extend SomeModule
  include AnotherModule

  # inner classes
  CustomError = Class.new(StandardError)

  # constants are next
  SOME_CONSTANT = 20

  # afterwards we have attribute macros
  attr_reader :name

  # followed by other macros (if any)
  validates :name

  # public class methods are next in line
  def self.some_method
  end

  # initialization goes between class methods and other instance methods
  def initialize
  end

  # followed by other public instance methods
  def some_method
  end

  # protected and private methods are grouped near the end
  protected

  def some_protected_method
  end

  private

  def some_private_method
  end
end</code></pre>
                    </li>
                    <li>
                      <p>Çoklu Mixin'leri ayrı ifadelere bölün.</p>
                      <pre><code class="language-ruby"># bad
class Person
  include Foo, Bar
end

# good
class Person
  # multiple mixins go in separate statements
  include Foo
  include Bar
end</code></pre>
                    </li>
                    <li>
                      <p>Çok satırlı sınıfları sınıf içine yerleştirmeyin. Bu gibi içe içe geçmiş sınıfların her birini, kendi dosyalarında, ana sınıf gibi adlandırılmış klasörde bulundurmaya çalışın.</p>
                      <pre><code class="language-ruby"># bad

# foo.rb
class Foo
  class Bar
    # 30 methods inside
  end

  class Car
    # 20 methods inside
  end

  # 30 methods inside
end

# good

# foo.rb
class Foo
  # 30 methods inside
end

# foo/bar.rb
class Foo
  class Bar
    # 30 methods inside
  end
end

# foo/car.rb
class Foo
  class Car
    # 20 methods inside
  end
end</code></pre>
                    </li>
                    <li>
                      <p>Ad alanlı sınıfları ve modülleri açıkça iç içe koyarak tanımlayın (ve yeniden açın). Kapsam çözünürlüğü operatörünü kullanmak, şaşırtıcı aramalara neden olabilir. Bu durum, modülün tanımlandığı yere bağlıdır.</p>
                      <pre><code class="language-ruby">module Utilities
  class Queue
  end
end

# bad
class Utilities::Store
  Module.nesting # => [Utilities::Store]

  def initialize
    # Refers to the top level ::Queue class because Utilities isn't in the
    # current nesting chain.
    @queue = Queue.new
  end
end

# good
module Utilities
  class WaitingList
    Module.nesting # => [Utilities::WaitingList, Utilities]

    def initialize
      @queue = Queue.new # Refers to Utilities::Queue
    end
  end
end</code></pre>
                    </li>
                    <li>
                      <p>Modülleri yalnızca sınıf yöntemlerine sahip sınıflara tercih edin. Sınıflar yalnızca onlardan örnekler oluşturmanın mantıklı olduğu durumlarda kullanılmalıdır.</p>
                      <pre><code class="language-ruby">class SomeClass
  def self.some_method
    # body omitted
  end

  def self.some_other_method
    # body omitted
  end
end

# good
module SomeModule
  module_function

  def some_method
    # body omitted
  end

  def some_other_method
    # body omitted
  end
end</code></pre>
                    </li>
                    <li>
                      <p>Bir modülün örnek yöntemlerini sınıf yöntemlerine dönüştürmek istediğinizde, <code>extend self</code> yerine <code>module_function</code> kullanın.</p>
                      <pre><code class="language-ruby"># bad
module Utilities
  extend self

  def parse_something(string)
    # do stuff here
  end

  def other_utility_method(number, string)
    # do some more stuff
  end
end

# good
module Utilities
  module_function

  def parse_something(string)
    # do stuff here
  end

  def other_utility_method(number, string)
    # do some more stuff
  end
end</code></pre>
                    </li>
                    <li>
                      <p>Sınıf hiyerarşileri tasarlanırken, <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" target="blank" rel="nofollow">Liskov Değiştirme Prensibi</a>'ne uyduklarından emin olun.</p>
                    </li>
                    <li>
                      <p>Sınıflarınızı olabildiğince <a href="https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)" target="blank" rel="nofollow">SOLID</a> yapmaya çalışın.</p>
                    </li>
                    <li>
                      <p>Etki alanı nesnelerini temsil eden sınıflar için her zaman uygun bir <code>to_s</code> yöntemi sağlayın.</p>
                      <pre><code class="language-ruby">class Person
  attr_reader :first_name, :last_name

  def initialize(first_name, last_name)
    @first_name = first_name
    @last_name = last_name
  end

  def to_s
    "#{first_name} #{last_name}"
  end
end</code></pre>
                    </li>
                    <li>
                      <p>Önemsiz erişimcileri tanımlamak için <code>attr</code> işlev ailesini kullanın.</p>
                      <pre><code class="language-ruby"># bad
class Person
  def initialize(first_name, last_name)
    @first_name = first_name
    @last_name = last_name
  end

  def first_name
    @first_name
  end

  def last_name
    @last_name
  end
end

# good
class Person
  attr_reader :first_name, :last_name

  def initialize(first_name, last_name)
    @first_name = first_name
    @last_name = last_name
  end
end</code></pre>
                    </li>
                    <li>
                      <p>Erişimciler için, <code>get_</code> ve <code>set_</code> ile yöntem adlarını öneklemekten kaçının. Okumak için öznitelik adlarını ve yazmak için <code>attr_name =</code> kullanmak bir Ruby kuralıdır.</p>
                      <pre><code class="language-ruby"># bad
class Person
  def get_name
    "#{@first_name} #{@last_name}"
  end

  def set_name(name)
    @first_name, @last_name = name.split(' ')
  end
end

# good
class Person
  def name
    "#{@first_name} #{@last_name}"
  end

  def name=(name)
    @first_name, @last_name = name.split(' ')
  end
end</code></pre>
                    </li>
                    <li>
                      <p><code>attr</code> kullanmaktan kaçının. Bunun yerine <code>attr_reader</code> ve <code>attr_accessor</code> kullanın.</p>
                      <pre><code class="language-ruby"># bad - creates a single attribute accessor (deprecated in Ruby 1.9)
attr :something, true
attr :one, :two, :three # behaves as attr_reader

# good
attr_accessor :something
attr_reader :one, :two, :three</code></pre>
                    </li>
                    <li>
                      <p>Önemsiz erişimcileri, kurucuları ve karşılaştırma operatörlerini sizin için tanımlayan <code>Struct.new</code>'i kullanmayı düşünün.</p>
                      <pre><code class="language-ruby"># good
class Person
  attr_accessor :first_name, :last_name

  def initialize(first_name, last_name)
    @first_name = first_name
    @last_name = last_name
  end
end

# better
Person = Struct.new(:first_name, :last_name) do
end</code></pre>
                    </li>
                    <li>
                      <p><code>Struct.new</code> tarafından başlatılan bir örneği genişletmeyin. Genişletmek gereksiz bir sınıf düzeyi sunar ve dosya birden çok kez istenirse garip hatalar ortaya çıkartabilir.</p>
                      <pre><code class="language-ruby"># bad
class Person < Struct.new(:first_name, :last_name)
end

# good
Person = Struct.new(:first_name, :last_name)</code></pre>
                    </li>
                    <li>
                      <p>Kalıtım yerine <a href="https://en.wikipedia.org/wiki/Duck_typing" target="blank" rel="nofollow">duck-typing</a> tercih edin.</p>
                      <pre><code class="language-ruby"># bad
class Animal
  # abstract method
  def speak
  end
end

# extend superclass
class Duck < Animal
  def speak
    puts 'Quack! Quack'
  end
end

# extend superclass
class Dog < Animal
  def speak
    puts 'Bau! Bau!'
  end
end

# good
class Duck
  def speak
    puts 'Quack! Quack'
  end
end

class Dog
  def speak
    puts 'Bau! Bau!'
  end
end</code></pre>
                    </li>
                    <li>
                      <p>Kalıtımdaki "kötü" davranışlarından dolayı sınıf (<code>@@</code>) değişkenlerinin kullanılmasından kaçının.</p>
                      <pre><code class="language-ruby">class Parent
  @@class_var = 'parent'

  def self.print_class_var
    puts @@class_var
  end
end

class Child < Parent
  @@class_var = 'child'
end

Parent.print_class_var # => will print 'child'</code></pre>
                      <p>Görebileceğiniz gibi, sınıf hiyerarşisindeki tüm sınıflar aslında bir sınıf değişkenini paylaşır. Örnek değişkenleri, genellikle sınıf değişkenleri yerine tercih edilmelidir.</p>
                    </li>
                    <li>
                      <p>Amaçlanan kullanımlarına göre yöntemlere (<code>private, protected</code>) uygun görünürlük seviyeleri atayın. Her şeyi herkese <code>public</code> bırakmayın (bu varsayılandır). Ne de olsa şimdi Ruby'de kodluyoruz, Python'da değil.</p>
                    </li>
                    <li>
                      <p><code>public</code>, <code>protected</code> ve <code>private</code> metodlar uygulandıkları metod tanımları kadar girintili olmalıdır. Aşağıdaki tüm yöntemlere uygulandığını vurgulamak için görünürlük değiştiricinin üzerinde ve altında boş bir satır bırakın.</p>
                      <pre><code class="language-ruby">class SomeClass
  def public_method
    # some code
  end

  private

  def private_method
    # some code
  end

  def another_private_method
    # some code
  end
end</code></pre>
                    </li>
                    <li>
                      <p>Sınıf yöntemlerini tanımlamak için <code>def self.method</code> kullanın. Bu, sınıf adı tekrarlanmadığından kodun yeniden yapılandırılmasını kolaylaştırır.</p>
                      <pre><code class="language-ruby">class TestClass
  # bad
  def TestClass.some_method
    # body omitted
  end

  # good
  def self.some_other_method
    # body omitted
  end

  # Also possible and convenient when you
  # have to define many class methods.
  class << self
    def first_method
      # body omitted
    end

    def second_method_etc
      # body omitted
    end
  end
end</code></pre>
                    </li>
                  </ul>
                  <h3 class="h4">Kurucular</h3>
                  <ul>
                    <li>
                      <p>Belirli bir sınıfın örneklerini oluşturmak için ek makul yollar sağlayan factory metodlarını kullanmayı düşünün.</p>
                      <pre><code class="language-ruby">class Person
  def self.create(options_hash)
    # body omitted
  end
end</code></pre>
                    </li>
                    <li>
                      <p>Yapıcılarda, örnek değişkenleri için gereksiz yere <code>||=</code> kullanmaktan kaçının. Düz atamayı tercih edin. Ruby'de, örnek değişkenleri (<code>@</code> ile başlayan) bir değer atanana kadar <code>nil</code>'dir.</p>
                      <pre><code class="language-ruby"># bad
def initialize
  @x ||= 1
end

# good
def initialize
  @x = 1
end</code></pre>
                    </li>
                  </ul>
                </section>
                <!-- / classes & modules -->

                <!-- exceptions -->
                <section id="section-6">
                  <h2 class="section-title-2">İstisnalar <a data-scroll href="#section-6" class="anchor" data-toggle="tooltip" data-placement="top" title="Linki kopyala"><i class="icon-hash"></i></a></h2>
                  <ul>
                    <li>
                      <p>İstisnalar için <code>fail</code> yerine <code>raise</code> kullanın.</p>
                      <pre><code class="language-ruby"># bad
fail SomeException, 'message'

# good
raise SomeException, 'message'</code></pre>
                    </li>
                    <li>
                      <p><code>RuntimeError</code> ifadesini açıkça belirtmeyin.</p>
                      <pre><code class="language-ruby"># bad
raise RuntimeError, 'message'

# good - signals a RuntimeError by default
raise 'message'</code></pre>
                    </li>
                    <li>
                      <p><code>raise</code> için istisna örneği yerine, istisna sınıfı ve mesajını iki ayrı argüman olarak vermeyi tercih edin.</p>
                      <pre><code class="language-ruby"># bad
raise SomeException.new('message')
# Note that there is no way to do `raise SomeException.new('message'), backtrace`.

# good
raise SomeException, 'message'
# Consistent with `raise SomeException, 'message', backtrace`.</code></pre>
                    </li>
                    <li>
                      <p><code>ensure</code> bloğundan geri dönüş yapmayın. <code>ensure</code> bloğu içindeki bir yöntemden dönerseniz, geri dönüş, ortaya atılan istisnalar karşısında öncelikli olacaktır ve yöntem hiçbir istisna ortaya çıkmamış gibi davranacaktır. Aslında, istisna (exception) sessizce fırlatılır.</p>
                      <pre><code class="language-ruby"># bad
def foo
  raise
ensure
  return 'very bad idea'
end</code></pre>
                    </li>
                    <li>
                      <p>Mümkün olduğunda üstü kapalı başlangıç blokları kullanın.</p>
                      <pre><code class="language-ruby"># bad
def foo
  begin
    # main logic goes here
  rescue
    # failure handling goes here
  end
end

# good
def foo
  # main logic goes here
rescue
  # failure handling goes here
end</code></pre>
                    </li>
                    <li>
                      <p>İstisnaları bastırmayın.</p>
                      <pre><code class="language-ruby"># bad
begin
  # an exception occurs here
rescue SomeError
  # the rescue clause does absolutely nothing
end

# bad
do_something rescue nil</code></pre>
                    </li>
                    <li>
                      <p>Değiştirici formunda <code>rescue</code> kullanmaktan kaçının.</p>
                      <pre><code class="language-ruby"># bad - this catches exceptions of StandardError class and its descendant classes
read_file rescue handle_error($!)

# good - this catches only the exceptions of Errno::ENOENT class and its descendant classes
def foo
  read_file
rescue Errno::ENOENT => e
  handle_error(e)
end</code></pre>
                    </li>
                    <li>
                      <p>Kontrol akışı için istisnalar kullanmayın.</p>
                      <pre><code class="language-ruby"># bad
begin
  n / d
rescue ZeroDivisionError
  puts 'Cannot divide by 0!'
end

# good
if d.zero?
  puts 'Cannot divide by 0!'
else
  n / d
end</code></pre>
                    </li>
                    <li>
                      <p><code>Exception</code> sınıfını kurtarmaktan kaçının. Bu, sinyalleri hapseder ve süreçte <code>kill -9</code> gerektiren <code>exit</code> yapar.</p>
                      <pre><code class="language-ruby"># bad
begin
  # calls to exit and kill signals will be caught (except kill -9)
  exit
rescue Exception
  puts "you didn't really want to exit, right?"
  # exception handling
end

# good
begin
  # a blind rescue rescues from StandardError, not Exception as many
  # programmers assume.
rescue => e
  # exception handling
end

# also good
begin
  # an exception occurs here
rescue StandardError => e
  # exception handling
end</code></pre>
                    </li>
                    <li>
                      <p>Kurtarma zincirinin üstüne daha özel istisnalar koyun, aksi takdirde asla kurtarılamazlar.</p>
                      <pre><code class="language-ruby"># bad
begin
  # some code
rescue StandardError => e
  # some handling
rescue IOError => e
  # some handling that will never be executed
end

# good
begin
  # some code
rescue IOError => e
  # some handling
rescue StandardError => e
  # some handling
end</code></pre>
                    </li>
                    <li>
                      <p>Programınız tarafından elde edilen dış kaynakları <code>ensure</code> bloğunda serbest bırakın.</p>
                      <pre><code class="language-ruby">f = File.open('testfile')
begin
  # .. process
rescue
  # .. handle error
ensure
  f.close if f
end</code></pre>
                    </li>
                    <li>
                      <p>Mümkün olduğunda otomatik kaynak temizliği yapan yöntemleri kullanın.</p>
                      <pre><code class="language-ruby"># bad - you need to close the file descriptor explicitly
f = File.open('testfile')
# some action on the file
f.close

# good - the file descriptor is closed automatically
File.open('testfile') do |f|
  # some action on the file
end</code></pre>
                    </li>
                    <li>
                      <p>Yeni istisna sınıfları tanımlamak yerine standart kütüphanedeki istisnaların kullanılmasını tercih edin.</p>
                    </li>
                  </ul>
                </section>
                <!-- / exceptions -->

                <!-- collections -->
                <section id="section-7">
                  <h2 class="section-title-2">Koleksiyonlar <a data-scroll href="#section-7" class="anchor" data-toggle="tooltip" data-placement="top" title="Linki kopyala"><i class="icon-hash"></i></a></h2>
                  <ul>
                    <li>
                      <p>Literal dizi ve çırpı (hash) oluşturma gösterimini tercih edin (parametreleri kuruculara iletmeniz gerekmiyorsa).</p>
                      <pre><code class="language-ruby"># bad
arr = Array.new
hash = Hash.new

# good
arr = []
arr = Array.new(10)
hash = {}
hash = Hash.new(0)</code></pre>
                    </li>
                    <li>
                      <p>Bir kelime dizisine (boş olmayan ve boşluk içermeyen) ihtiyacınız olduğunda, literal dizi sözdizimi yerine <code>%w</code> tercih edin. Bu kuralı yalnızca iki veya daha fazla öğeli dizilere uygulayın.</p>
                      <pre><code class="language-ruby"># bad
STATES = ['draft', 'open', 'closed']

# good
STATES = %w[draft open closed]</code></pre>
                    </li>
                    <li>
                      <p>Bir sembol dizisine ihtiyaç duyduğunuzda, literal dizi sözdizimi yerine <code>%i</code> tercih edin. Bu kuralı yalnızca iki veya daha fazla öğeli dizilere uygulayın.</p>
                      <pre><code class="language-ruby"># bad
STATES = [:draft, :open, :closed]

# good
STATES = %i[draft open closed]</code></pre>
                    </li>
                    <li>
                      <p><code>Array</code> veya <code>Hash</code> literallerin son öğesinden sonra virgül kullanmaktan kaçının.</p>
                      <pre><code class="language-ruby"># bad - easier to move/add/remove items, but still not preferred
VALUES = [
           1001,
           2020,
           3333,
         ]

# bad
VALUES = [1001, 2020, 3333, ]

# good
VALUES = [1001, 2020, 3333]</code></pre>
                    </li>
                    <li>
                      <p>Dizilerde çok büyük boşluklar oluşturmaktan kaçının.</p>
                      <pre><code class="language-ruby">arr = []
arr[100] = 1 # now you have an array with lots of nils</code></pre>
                    </li>
                    <li>
                      <p>Bir dizinin ilk veya son elemanına erişirken, <code>[0]</code> veya <code>[-1]</code> yerine <code>first</code> veya <code>last</code> kullanın.</p>
                    </li>
                    <li>
                      <p>Benzersiz öğelerle çalışırken <code>Array</code> yerine <code>Set</code> kullanın. <code>Set</code>, benzeri olmayan sıralanmamış değerler topluluğu oluşturur. Bu, <code>Array</code>'in' sezgisel operasyonlar arası olanaklarından ve <code>Hash</code>'in hızlı aramasından oluşan bir melezdir.</p>
                    </li>
                    <li>
                      <p>Çırpı anahtarları olarak sembolleri tercih edin.</p>
                      <pre><code class="language-ruby"># bad
hash = { 'one' => 1, 'two' => 2, 'three' => 3 }

# good
hash = { one: 1, two: 2, three: 3 }</code></pre>
                    </li>
                    <li>
                      <p>Değişken nesneleri çırpı anahtarı olarak kullanmaktan kaçının.</p>
                    </li>
                    <li>
                      <p>Çırpı anahtarlarınız sembol olduğunda Ruby 1.9 literal sözdizimini kullanın.</p>
                      <pre><code class="language-ruby"># bad
hash = { :one => 1, :two => 2, :three => 3 }

# good
hash = { one: 1, two: 2, three: 3 }</code></pre>
                    </li>
                    <li>
                      <p>Çırpı sözdizimlerini birbirine karıştırmayın. Sembol olmayan anahtarlara sahip olduğunuzda roket sözdizimine sadık kalırsınız.</p>
                      <pre><code class="language-ruby"># bad
{ a: 1, 'b' => 2 }

# good
{ :a => 1, 'b' => 2 }</code></pre>
                    </li>
                    <li>
                      <p><code>Hash#has_key?</code> yerine <code>Hash#key?</code> ve <code>Hash#has_value?</code> yerine <code>Hash#value?</code> kullanın.</p>
                      <pre><code class="language-ruby"># bad
hash.has_key?(:test)
hash.has_value?(value)

# good
hash.key?(:test)
hash.value?(value)</code></pre>
                    </li>
                    <li>
                      <p><code>Hash#keys.each</code> yerine <code>Hash#each_key</code> ve <code>Hash#values.each</code> yerine <code>Hash#each_value</code> kullanın.</p>
                      <pre><code class="language-ruby"># bad
hash.keys.each { |k| p k }
hash.values.each { |v| p v }
hash.each { |k, _v| p k }
hash.each { |_k, v| p v }

# good
hash.each_key { |k| p k }
hash.each_value { |v| p v }</code></pre>
                    </li>
                    <li>
                      <p>Mevcut olması gereken çırpı anahtarlarıyla çalışırken <code>Hash#fetch</code> kullanın.</p>
                      <pre><code class="language-ruby">heroes = { batman: 'Bruce Wayne', superman: 'Clark Kent' }
# bad - if we make a mistake we might not spot it right away
heroes[:batman] # => 'Bruce Wayne'
heroes[:supermann] # => nil

# good - fetch raises a KeyError making the problem obvious
heroes.fetch(:supermann)</code></pre>
                    </li>
                    <li>
                      <p>Özel mantık yerine <code>Hash#fetch</code> ile varsayılan değer kullanın.</p>
                      <pre><code class="language-ruby">batman = { name: 'Bruce Wayne', is_evil: false }

# bad - if we just use || operator with falsy value we won't get the expected result
batman[:is_evil] || true # => true

# good - fetch works correctly with falsy values
batman.fetch(:is_evil, true) # => false</code></pre>
                    </li>
                    <li>
                      <p>Bir çırpıdan birbirini izleyen birkaç değer almanız gerektiğinde <code>Hash#values_at</code> kullanın.</p>
                      <pre><code class="language-ruby"># bad
email = data['email']
username = data['nickname']

# good
email, username = data.values_at('email', 'nickname')</code></pre>
                    </li>
                    <li>
                      <p>Ruby 1.9'dan itibaren çırpıların sıralı olduğuna güvenebilirsiniz.</p>
                    </li>
                  </ul>
                </section>
                <!-- / collections -->

                <!-- numbers -->
                <section id="section-8">
                  <h2 class="section-title-2">Sayılar <a data-scroll href="#section-8" class="anchor" data-toggle="tooltip" data-placement="top" title="Linki kopyala"><i class="icon-hash"></i></a></h2>
                  <ul>
                    <li>
                      <p>Bir tamsayının türünü kontrol etmek için <code>Integer</code> kullanın. <code>Fixnum</code> platforma bağlı olduğundan, 32 bit ve 64 bit makinelerde farklı sonuçlar verecektir.</p>
                      <pre><code class="language-ruby">timestamp = Time.now.to_i

# bad
timestamp.is_a? Fixnum
timestamp.is_a? Bignum

# good
timestamp.is_a? Integer</code></pre>
                    </li>
                    <li>
                      <p>Rastgele sayılar üretirken sayı aralığı kullanmayı tercih edin. Bir zar atışını taklit ettiğinizi düşünün:</p>
                      <pre><code class="language-ruby"># bad
rand(6) + 1

# good
rand(1..6)</code></pre>
                    </li>
                  </ul>
                </section>
                <!-- / numbers -->

                <!-- strings -->
                <section id="section-9">
                  <h2 class="section-title-2">Dizeler <a data-scroll href="#section-9" class="anchor" data-toggle="tooltip" data-placement="top" title="Linki kopyala"><i class="icon-hash"></i></a></h2>
                  <ul>
                    <li>
                      <p>Dize birleştirme yerine dize interpolasyonu ve dize formatını tercih edin:</p>
                      <pre><code class="language-ruby"># bad
email_with_name = user.name + ' <' + user.email + '>'

# good
email_with_name = "#{user.name} <#{user.email}>"

# good
email_with_name = format('%s <%s>', user.name, user.email)</code></pre>
                    </li>
                    <li>
                      <p>Tutarlı bir dize tırnak tarzı benimseyin. Ruby topluluğunda, iki popüler stil vardır - varsayılan olarak tek tırnak (Seçenek A) ve varsayılan olarak çift tırnak (Seçenek B).</p>
                      <ul>
                        <li>
                          <p><b>(Seçenek A)</b> Dizi interpolasyonuna veya <code>\t</code>, <code>\n</code>, <code>'</code>, vb. özel sembollere gerek duymuyorsanız, tek tırnaklı dizeleri tercih edin.</p>
                          <pre><code class="language-ruby"># bad
name = "Bozhidar"

name = 'De\'Andre'

# good
name = 'Bozhidar'

name = "De'Andre"</code></pre>
                        </li>
                        <li>
                          <p><b>(Seçenek B)</b> Dizeniz <code>"</code> ya da kaçış karakteri içermiyorsa, çift tırnak tercih edin.</p>
                          <pre><code class="language-ruby"># bad
name = 'Bozhidar'

sarcasm = "I \"like\" it."

# good
name = "Bozhidar"

sarcasm = 'I "like" it.'</code></pre>
                        </li>
                      </ul>
                      <p>Bu klavuzda ilk stil tercih edilmiştir.</p>
                    </li>
                    <li>
                      <p><code>?x</code> sözdizimini kullanmayın. Ruby 1.9'dan beri temelde gereksizdir - <code>?x</code> <code>'x'</code> olarak yorumlanır.</p>
                      <pre><code class="language-ruby"># bad
char = ?c

# good
char = 'c'</code></pre>
                    </li>
                    <li>
                      <p>Örnek ve global değişkenleri <code>{}</code> dışında bırakmayın.</p>
                      <pre><code class="language-ruby">class Person
  attr_reader :first_name, :last_name

  def initialize(first_name, last_name)
    @first_name = first_name
    @last_name = last_name
  end

  # bad - valid, but awkward
  def to_s
    "#@first_name #@last_name"
  end

  # good
  def to_s
    "#{@first_name} #{@last_name}"
  end
end

$global = 0
# bad
puts "$global = #$global"

# good
puts "$global = #{$global}"</code></pre>
                    </li>
                    <li>
                      <p>İnterpolasyonlu nesnelerde <code>Object#to_s</code> - otomatik olarak çağrıldığı için - kullanmayın.</p>
                      <pre><code class="language-ruby"># bad
message = "This is the #{result.to_s}."

# good
message = "This is the #{result}."</code></pre>
                    </li>
                    <li>
                      <p>Büyük veri parçaları oluşturmanız gerektiğinde <code>String#+</code> kullanmaktan kaçının, bunun yerine, <code>String#<<</code> kullanın. Birleştirme, dize örneğini yerinde değiştirir ve her zaman yeni dize nesneleri oluşturan <code>String#+</code>'dan daha hızlıdır.</p>
                      <pre><code class="language-ruby"># bad
html = ''
html += '<h1>Page title</h1>'

paragraphs.each do |paragraph|
  html += "<p>#{paragraph}</p>"
end

# good and also fast
html = ''
html << '<h1>Page title</h1>'

paragraphs.each do |paragraph|
  html << "<p>#{paragraph}</p>"
end</code></pre>
                    </li>
                    <li>
                      <p>Daha hızlı ve daha özel bir alternatif kullanabileceğiniz senaryolarda <code>String#gsub</code> kullanmayın.</p>
                      <pre><code class="language-ruby">url = 'http://example.com'
str = 'lisp-case-rules'

# bad
url.gsub('http://', 'https://')
str.gsub('-', '_')

# good
url.sub('http://', 'https://')
str.tr('-', '_')</code></pre>
                    </li>
                  </ul>
                </section>
                <!-- / strings -->

                <!-- date & time -->
                <section id="section-10">
                  <h2 class="section-title-2">Tarih ve Saat <a data-scroll href="#section-10" class="anchor" data-toggle="tooltip" data-placement="top" title="Linki kopyala"><i class="icon-hash"></i></a></h2>
                  <ul>
                    <li>
                      <p>Geçerli sistem saatini alırken, <code>Time.new</code> yerine <code>Time.now</code> tercih edin.</p>
                    </li>
                    <li>
                      <p>Tarihsel takvim reformunu hesaba katmanız gerekmediği sürece <code>DateTime</code> kullanmayın.</p>
                      <pre><code class="language-ruby"># bad - uses DateTime for current time
DateTime.now

# good - uses Time for current time
Time.now

# bad - uses DateTime for modern date
DateTime.iso8601('2016-06-29')

# good - uses Date for modern date
Date.iso8601('2016-06-29')

# good - uses DateTime with start argument for historical date
DateTime.iso8601('1751-04-23', Date::ENGLAND)</code></pre>
                    </li>
                  </ul>
                </section>
                <!-- / date & time -->

                <!-- regular expressions -->
                <section id="section-11">
                  <h2 class="section-title-2">Düzenli İfadeler <a data-scroll href="#section-11" class="anchor" data-toggle="tooltip" data-placement="top" title="Linki kopyala"><i class="icon-hash"></i></a></h2>
                  <ul>
                    <li>
                      <p>Dizede düz metin aramaya ihtiyacınız varsa düzenli ifadeleri kullanmayın: <code>string['text']</code></p>
                    </li>
                    <li>
                      <p>Basit yapılar için regexp'i doğrudan dize indeksi üzerinden kullanabilirsiniz.</p>
                      <pre><code class="language-ruby">match = string[/regexp/] # get content of matched regexp
first_group = string[/text(grp)/, 1] # get content of captured group
string[/text (grp)/, 1] = 'replace' # string => 'text replace'</code></pre>
                    </li>
                    <li>
                      <p>Yakalanan sonucu kullanmadığınızda diğer grupları kullanın.</p>
                      <pre><code class="language-ruby"># bad
/(first|second)/

# good
/(?:first|second)/</code></pre>
                    </li>
                    <li>
                      <p>Son regexp grup eşleşmelerini ifade eden Perl değişkenlerini (<code>$1</code>, <code>$2</code>, vb.) kullanmayın. Bunun yerine <code>Regexp.last_match(n)</code> kullanın.</p>
                      <pre><code class="language-ruby">/(regexp)/ =~ string
...

# bad
process $1

# good
process Regexp.last_match(1)</code></pre>
                    </li>
                    <li>
                      <p>Numaralandırılmış grupları kullanmaktan kaçının çünkü içerdikleri şeyleri izlemek zor olabilir. Bunun yerine adlandırılmış gruplar kullanılabilir.</p>
                      <pre><code class="language-ruby"># bad
/(regexp)/ =~ string
# some code
process Regexp.last_match(1)

# good
/(?<meaningful_var>regexp)/ =~ string
# some code
process meaningful_var</code></pre>
                    </li>
                    <li>
                      <p>Karakter sınıfları, dikkat etmeniz gereken sadece birkaç özel karakter içerir: <code>^</code>, <code>-</code>, <code>\</code>, <code>]</code>, bu yüzden <code>.</code> veya <code>[]</code> içindeki köşeli ayraçlardan kaçmayın.</p>
                    </li>
                    <li>
                      <p>Karmaşık regexp işlemleri için <code>x</code> değiştiricisini kullanın. Bu onları daha okunaklı hale getirir ve bazı faydalı yorumlar ekleyebilirsiniz. Yalnızca, boşluklar göz ardı edilirken dikkatli olun.</p>
                      <pre><code class="language-ruby">regexp = /
  start         # some text
  \s            # white space char
  (group)       # first group
  (?:alt1|alt2) # some alternation
  end
/x</code></pre>
                    </li>
                    <li>
                      <p>Karmaşık değiştirmeler için <code>sub/gsub</code> bir blok veya çırpı ile kullanılabilir.</p>
                      <pre><code class="language-ruby">words = 'foo bar'
words.sub(/f/, 'f' => 'F') # => 'Foo bar'
words.gsub(/\w+/) { |word| word.capitalize } # => 'Foo Bar'</code></pre>
                    </li>
                  </ul>
                </section>
                <!-- / regular expressions -->

                <!-- percent literals -->
                <section id="section-12">
                  <h2 class="section-title-2">Literaller <a data-scroll href="#section-12" class="anchor" data-toggle="tooltip" data-placement="top" title="Linki kopyala"><i class="icon-hash"></i></a></h2>
                  <ul>
                    <li>
                      <p>Hem interpolasyon hem de çift tırnak gerektiren tek satırlı dizeler için <code>%()</code> (<code>%Q</code> için kısa yoldur) kullanın. Çok satırlı dizeler için, heredoc'u seçin.</p>
                      <pre><code class="language-ruby"># bad (no interpolation needed)
%(&lt;div class="text"&gt;Some text&lt;/div&gt;)
# should be '&lt;div class="text"&gt;Some text&lt;/div&gt;'

# bad (no double-quotes)
%(This is #{quality} style)
# should be "This is #{quality} style"

# bad (multiple lines)
%(&lt;div&gt;\n&lt;span class="big"&gt;#{exclamation}&lt;/span&gt;\n&lt;/div&gt;)
# should be a heredoc.

# good (requires interpolation, has quotes, single line)
%(&lt;tr&gt;&lt;td class="name"&gt;#{name}&lt;/td&gt;)</code></pre>
                    </li>
                    <li>
                      <p>İçinde hem <code>'</code> hem de <code>"</code> olan bir dize olmadıkça <code>%()</code> veya eşdeğer <code>%q()</code> kullanmaktan kaçının. Normal dize literalleri daha okunaklıdır ve çok sayıda karakterden kaçmanıza gerek yoksa tercih edilmelidir.</p>
                      <pre><code class="language-ruby"># bad
name = %q(Bruce Wayne)
time = %q(8 o'clock)
question = %q("What did you say?")

# good
name = 'Bruce Wayne'
time = "8 o'clock"
question = '"What did you say?"'
quote = %q(&lt;p class='quote'&gt;"What did you say?"&lt;/p&gt;)</code></pre>
                    </li>
                    <li>
                      <p><code>%r</code> ifadesini sadece en az bir <code>'/'</code> karakteriyle eşleşen normal ifadeler için kullanın.</p>
                      <pre><code class="language-ruby"># bad
%r{\s+}

# good
%r{^/(.*)$}
%r{^/blog/2011/(.*)$}</code></pre>
                    </li>
                    <li>
                      <p>İçinde <code>`</code> olan bir komutu çağırmayacaksanız, <code>%x</code> kullanmaktan kaçının.</p>
                      <pre><code class="language-ruby"># bad
date = %x(date)

# good
date = `date`
echo = %x(echo `date`)</code></pre>
                    </li>
                    <li>
                      <p>%s kullanmaktan kaçının. <code>"some string"</code>, içinde boşluk bulunan bir sembol oluşturmanın tercih edilen yoludur.</p>
                    </li>
                  </ul>
                </section>
                <!-- / percent literals -->

                <!-- metaprogramming -->
                <section id="section-13">
                  <h2 class="section-title-2">Meta Programlama <a data-scroll href="#section-13" class="anchor" data-toggle="tooltip" data-placement="top" title="Linki kopyala"><i class="icon-hash"></i></a></h2>
                  <ul>
                    <li>
                      <p>Gereksiz metaprogramlama yapmaktan kaçının.</p>
                    </li>
                    <li>
                      <p>Kütüphane yazarken çekirdek sınıfların çevresinde çalışmayın. (monkey-patch yapmayın.)</p>
                    </li>
                    <li>
                      <p><code>class_eval</code>'in blok formu, dize interpolasyonlu forma tercih edilir.</p>
                      <ul>
                        <li>
                          <p>String interpolasyonlu formu kullandığınızda, her zaman <code>__FILE__</code> ve <code>__LINE__</code> parametrelerini verin, böylece backtraces'leriniz mantıklı olacaktır:</p>
                          <pre><code class="language-ruby">class_eval 'def use_relative_model_naming?; true; end', __FILE__, __LINE__</code></pre>
                        </li>
                        <li>
                          <p><code>define_method</code>, <code>class_eval{ def ... }</code>'e tercih edilir.</p>
                        </li>
                      </ul>
                    </li>
                    <li>
                      <p><code>private/protected</code> görünürlüğü engellememek için <code>send</code> yerine <code>public_send</code>'i kullanın.</p>
                      <pre><code class="language-ruby"># We have an ActiveModel Organization that includes concern Activatable
module Activatable
  extend ActiveSupport::Concern

  included do
    before_create :create_token
  end

  private

  def reset_token
    # some code
  end

  def create_token
    # some code
  end

  def activate!
    # some code
  end
end

class Organization < ActiveRecord::Base
  include Activatable
end

linux_organization = Organization.find(...)
# BAD - violates privacy
linux_organization.send(:reset_token)
# GOOD - should throw an exception
linux_organization.public_send(:reset_token)</code></pre>
                    </li>
                    <li>
                      <p><code>send</code> yerine <code>__send__</code> tercih edin, çünkü <code>send</code> mevcut yöntemlerle çakışabilir.</p>
                      <pre><code class="language-ruby">require 'socket'

u1 = UDPSocket.new
u1.bind('127.0.0.1', 4913)
u2 = UDPSocket.new
u2.connect('127.0.0.1', 4913)
# Won't send a message to the receiver obj.
# Instead it will send a message via UDP socket.
u2.send :sleep, 0
# Will actually send a message to the receiver obj.
u2.__send__ ...</code></pre>
                    </li>
                  </ul>
                </section>
                <!-- / metaprogramming -->

                <!-- misc -->
                <section id="section-14">
                  <h2 class="section-title-2">Genel <a data-scroll href="#section-14" class="anchor" data-toggle="tooltip" data-placement="top" title="Linki kopyala"><i class="icon-hash"></i></a></h2>
                  <ul>
                    <li>
                      <p><code>ruby -w</code> ile güvenli kod yazın.</p>
                    </li>
                    <li>
                      <p>İsteğe bağlı parametre olarak çırpı kullanmaktan kaçının. (Nesne başlatıcıları bu kuralın istisnalarıdır).</p>
                    </li>
                    <li>
                      <p>10 satırdan uzun kodlardan kaçının. İdeal olarak, çoğu yöntem 5 satırdan daha kısa olacaktır.</p>
                    </li>
                    <li>
                      <p>Üç veya dört parametreden daha uzun parametre listelerinden kaçının.</p>
                    </li>
                    <li>
                      <p>Eğer gerçekten "global" yöntemlere ihtiyacınız varsa, bunları Kernel'e ekleyin ve kişiselleştirin.</p>
                    </li>
                    <li>
                      <p>Global değişkenler yerine modül örnek değişkenlerini kullanın.</p>
                      <pre><code class="language-ruby"># bad
$foo_bar = 1

# good
module Foo
  class << self
    attr_accessor :bar
  end
end

Foo.bar = 1</code></pre>
                    </li>
                    <li>
                      <p>Karmaşık komut satırı seçeneklerini ayrıştırmak için <code>OptionParser</code> ve önemsiz komut satırı seçenekleri için <code>ruby -s</code> komutunu kullanın.</p>
                    </li>
                    <li>
                      <p>İşlevsel bir şekilde kodlayın, mantıklı olduğunda mutasyondan kaçının.</p>
                      <pre><code class="language-ruby">a = []; [1, 2, 3].each { |i| a << i * 2 } # bad
a = [1, 2, 3].map { |i| i * 2 } # good

a = {}; [1, 2, 3].each { |i| a[i] = i * 17 } # bad
a = [1, 2, 3].reduce({}) { |h, i| h[i] = i * 17; h } # good
a = [1, 2, 3].each_with_object({}) { |i, h| h[i] = i * 17 } # good</code></pre>
                    </li>
                    <li>
                      <p>Yöntemin amacı bu olmadığı sürece parametreleri mutasyona uğratmayın.</p>
                    </li>
                    <li>
                      <p>Üç seviyeden fazla bloğu iç içe geçirmekten kaçının.</p>
                    </li>
                    <li>
                      <p>Tutarlı olun. İdeal bir dünyada, bu rehberdeki prensiplere uyun.</p>
                    </li>
                    <li>
                      <p>Sağduyunuzu kullanın.</p>
                    </li>
                  </ul>
                </section>
                <!-- / misc -->

                <!-- tools -->
                <section id="section-15">
                  <h2 class="section-title-2">Araçlar <a data-scroll href="#section-15" class="anchor" data-toggle="tooltip" data-placement="top" title="Linki kopyala"><i class="icon-hash"></i></a></h2>
                  <p>Ruby kodunu bu kılavuza göre otomatik olarak kontrol etmenize yardımcı olacak bazı araçlar.</p>
                  <h3 class="h4">RuboCop</h3>
                  <p><a href="https://github.com/rubocop-hq/rubocop" target="blank" rel="nofollow">RuboCop</a>, bu stil rehberine dayanan Ruby statik kod analizörü ve biçimlendiricisidir.</p>
                  <h3 class="h4">RubyMine</h3>
                  <p><a href="https://www.jetbrains.com/ruby/" target="blank" rel="nofollow">RubyMine</a>'nın kod kontrolü kısmen bu stil rehberine dayanmaktadır.</p>
                </section>
                <!-- / tools -->

              </article>

              <aside class="col-md-3 col-xxl-3 d-none d-md-block">
                <div class="sticky">
                  <ul id="toc" class="nav flex-column toc">
                    <li class="nav-item">
                      <a data-scroll class="nav-link" href="#section-1">Kaynak Kod Düzeni</a>
                    </li>
                    <li class="nav-item">
                      <a data-scroll class="nav-link" href="#section-2">Sözdizimi</a>
                    </li>
                    <li class="nav-item">
                      <a data-scroll class="nav-link" href="#section-3">Adlandırma</a>
                    </li>
                    <li class="nav-item">
                      <a data-scroll class="nav-link" href="#section-4">Yorumlar</a>
                    </li>
                    <li class="nav-item">
                      <a data-scroll class="nav-link" href="#section-5">Sınıflar ve Modüller</a>
                    </li>
                    <li class="nav-item">
                      <a data-scroll class="nav-link" href="#section-6">İstisnalar</a>
                    </li>
                    <li class="nav-item">
                      <a data-scroll class="nav-link" href="#section-7">Koleksiyonlar</a>
                    </li>
                    <li class="nav-item">
                      <a data-scroll class="nav-link" href="#section-8">Sayılar</a>
                    </li>
                    <li class="nav-item">
                      <a data-scroll class="nav-link" href="#section-9">Dizeler</a>
                    </li>
                    <li class="nav-item">
                      <a data-scroll class="nav-link" href="#section-10">Tarih ve Saat</a>
                    </li>
                    <li class="nav-item">
                      <a data-scroll class="nav-link" href="#section-11">Düzenli İfadeler</a>
                    </li>
                    <li class="nav-item">
                      <a data-scroll class="nav-link" href="#section-12">Literaller</a>
                    </li>
                    <li class="nav-item">
                      <a data-scroll class="nav-link" href="#section-13">Meta Programlama</a>
                    </li>
                    <li class="nav-item">
                      <a data-scroll class="nav-link" href="#section-14">Genel</a>
                    </li>
                    <li class="nav-item">
                      <a data-scroll class="nav-link" href="#section-15">Araçlar</a>
                    </li>
                  </ul>
                </div>
              </aside>

            </div>

          </article>
          <!-- / content -->

        </div>
      </div>
    </section>

    <!-- footer -->
    <footer class="bg-dark">
      <div class="container">
        <div class="row gutter-3">
          <div class="col-12 col-md-2">
            <a href=""><img src="assets/images/logo-white.png" alt="Logo"></a>
          </div>
          <div class="col-12 col-md-6 text-white">
            <p class="mb-4"><a href="https://github.com/rubocop-hq/ruby-style-guide" target="blank" rel="nofollow">Rubocop</a> stil rehberinden esinlenilmiştir. Bu içerik <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US" target="blank" rel="nofollow">Creative Commons Attribution 3.0 Unported License</a> lisansı altındadır.</p>
            <p>Yayıncı, <a href="https://www.melihkocaturk.com/" target="blank">Melih Kocatürk</a></p>
          </div>
          <div class="col-12 col-md-4 col-lg-2 ml-auto text-md-right">
            <div class="dropdown">
              <button class="btn btn-inverted btn-block dropdown-toggle" type="button" id="dropdownMenuButton" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                Türkçe
              </button>
              <div class="dropdown-menu" aria-labelledby="dropdownMenuButton">
                <a class="dropdown-item" href="https://github.com/rubocop-hq/ruby-style-guide" target="blank" rel="nofollow">English</a>
              </div>
            </div>
          </div>
        </div>
      </div>
    </footer>
    <!-- / footer -->

    <script src="assets/js/vendor.js"></script>
    <script src="assets/js/app.js"></script>
  </body>
</html>